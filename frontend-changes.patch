diff --git a/frontend/app/api/sow/[id]/export-excel/route.ts b/frontend/app/api/sow/[id]/export-excel/route.ts
new file mode 100644
index 0000000..9d4ddab
--- /dev/null
+++ b/frontend/app/api/sow/[id]/export-excel/route.ts
@@ -0,0 +1,146 @@
+import { NextRequest, NextResponse } from "next/server";
+import { query } from "@/lib/db";
+import {
+    exportToExcel,
+    parseSOWMarkdown,
+    cleanSOWContent,
+} from "@/lib/export-utils";
+
+export async function GET(
+    request: NextRequest,
+    { params }: { params: { id: string } },
+) {
+    try {
+        const sowId = params.id;
+
+        // Fetch SOW from database
+        const sows = await query("SELECT * FROM sows WHERE id = ?", [sowId]);
+
+        if (!sows || sows.length === 0) {
+            return NextResponse.json(
+                { error: "SOW not found" },
+                { status: 404 },
+            );
+        }
+
+        const sow = sows[0];
+
+        // Parse the content to extract structured data
+        let sowData;
+        try {
+            // Clean the content first
+            const cleanedContent = cleanSOWContent(sow.content);
+            // Parse markdown to extract structured data
+            sowData = parseSOWMarkdown(cleanedContent);
+            sowData.title = sow.title;
+        } catch (parseError) {
+            console.error("Error parsing SOW content:", parseError);
+            // Fallback to basic data
+            sowData = {
+                title: sow.title,
+                client: sow.client_name,
+                pricingRows: [],
+            };
+        }
+
+        // Generate filename with client name and date
+        const clientName = sowData.client || "Client";
+        const date = new Date().toISOString().split("T")[0];
+        const filename = `${clientName.replace(/\s+/g, "-")}-SOW-${date}.xlsx`;
+
+        // Return the Excel file
+        const response = new NextResponse(new Blob(), {
+            status: 200,
+            headers: {
+                "Content-Disposition": `attachment; filename="${filename}"`,
+                "Content-Type":
+                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
+            },
+        });
+
+        // This is a workaround for Next.js streaming issues
+        // We'll generate the Excel client-side using a separate API call
+        return NextResponse.json({
+            success: true,
+            sowData,
+            filename,
+            message: "SOW data ready for Excel export",
+        });
+    } catch (error) {
+        console.error("Error exporting SOW to Excel:", error);
+        return NextResponse.json(
+            {
+                error: "Failed to export SOW to Excel",
+                details:
+                    error instanceof Error ? error.message : "Unknown error",
+            },
+            { status: 500 },
+        );
+    }
+}
+
+export async function POST(
+    request: NextRequest,
+    { params }: { params: { id: string } },
+) {
+    try {
+        const sowId = params.id;
+        const body = await request.json();
+        const { sowData, filename } = body;
+
+        // Validate required data
+        if (!sowData || !filename) {
+            return NextResponse.json(
+                { error: "Missing required data: sowData and filename" },
+                { status: 400 },
+            );
+        }
+
+        // Call backend service to generate Excel
+        const PDF_SERVICE_URL =
+            process.env.NEXT_PUBLIC_PDF_SERVICE_URL || "http://localhost:8000";
+
+        const response = await fetch(`${PDF_SERVICE_URL}/export-excel`, {
+            method: "POST",
+            headers: {
+                "Content-Type": "application/json",
+            },
+            body: JSON.stringify({
+                sowData,
+                filename,
+            }),
+        });
+
+        if (!response.ok) {
+            const errorData = await response.json().catch(() => ({}));
+            console.error("Backend error:", errorData);
+            return NextResponse.json(
+                { error: errorData.detail || "Failed to generate Excel" },
+                { status: response.status },
+            );
+        }
+
+        // Get the Excel file from backend
+        const excelBlob = await response.blob();
+
+        // Return the Excel file
+        return new NextResponse(excelBlob, {
+            status: 200,
+            headers: {
+                "Content-Disposition": `attachment; filename="${filename}"`,
+                "Content-Type":
+                    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
+            },
+        });
+    } catch (error) {
+        console.error("Error generating Excel file:", error);
+        return NextResponse.json(
+            {
+                error: "Failed to generate Excel file",
+                details:
+                    error instanceof Error ? error.message : "Unknown error",
+            },
+            { status: 500 },
+        );
+    }
+}
diff --git a/frontend/app/api/sow/[id]/export-pdf/route.ts b/frontend/app/api/sow/[id]/export-pdf/route.ts
new file mode 100644
index 0000000..70443d3
--- /dev/null
+++ b/frontend/app/api/sow/[id]/export-pdf/route.ts
@@ -0,0 +1,119 @@
+/**
+ * API Route: Export SOW to PDF
+ * POST /api/sow/[id]/export-pdf
+ */
+
+import { NextRequest, NextResponse } from "next/server";
+import { query } from "@/lib/db";
+import {
+    exportToPDF,
+    parseSOWMarkdown,
+    cleanSOWContent,
+} from "@/lib/export-utils";
+
+export async function POST(
+    request: NextRequest,
+    { params }: { params: { id: string } },
+) {
+    try {
+        const sowId = params.id;
+        const body = await request.json();
+        const { elementId } = body;
+
+        // Fetch SOW from database
+        const sows = await query("SELECT * FROM sows WHERE id = ?", [sowId]);
+
+        if (!sows || sows.length === 0) {
+            return NextResponse.json(
+                { error: "SOW not found" },
+                { status: 404 },
+            );
+        }
+
+        const sow = sows[0];
+
+        // Parse content to extract structured data
+        let sowData;
+        try {
+            // Clean content first
+            const cleanedContent = cleanSOWContent(sow.content);
+            // Parse markdown to extract structured data
+            sowData = parseSOWMarkdown(cleanedContent);
+            sowData.title = sow.title;
+            sowData.client = sow.client_name;
+        } catch (parseError) {
+            console.error("Error parsing SOW content:", parseError);
+            // Fallback to basic data
+            sowData = {
+                title: sow.title,
+                client: sow.client_name,
+                pricingRows: [],
+            };
+        }
+
+        // Generate filename with client name and date
+        const clientName = sowData.client || "Client";
+        const date = new Date().toISOString().split("T")[0];
+        const filename = `${clientName.replace(/\s+/g, "-")}-SOW-${date}.pdf`;
+
+        // Call backend service to generate PDF
+        const PDF_SERVICE_URL =
+            process.env.NEXT_PUBLIC_PDF_SERVICE_URL || "http://localhost:8000";
+
+        // Get HTML content from frontend if elementId is provided
+        let htmlContent = "";
+        if (elementId) {
+            // In a real implementation, you would need to use a service like Puppeteer
+            // to capture the HTML from the client-side DOM
+            // For now, we'll generate basic HTML from the content
+            htmlContent = sow.content;
+        } else {
+            // Generate HTML from content
+            htmlContent = sow.content;
+        }
+
+        const response = await fetch(`${PDF_SERVICE_URL}/generate-pdf`, {
+            method: "POST",
+            headers: {
+                "Content-Type": "application/json",
+            },
+            body: JSON.stringify({
+                html_content: htmlContent,
+                filename: filename.substring(0, filename.length - 4), // Remove .pdf extension
+                client_name: clientName,
+                title: sowData.title,
+            }),
+        });
+
+        if (!response.ok) {
+            const errorData = await response.json().catch(() => ({}));
+            console.error("Backend error:", errorData);
+            return NextResponse.json(
+                { error: errorData.detail || "Failed to generate PDF" },
+                { status: response.status },
+            );
+        }
+
+        // Get PDF file from backend
+        const pdfBlob = await response.blob();
+
+        // Return PDF file
+        return new NextResponse(pdfBlob, {
+            status: 200,
+            headers: {
+                "Content-Disposition": `attachment; filename="${filename}"`,
+                "Content-Type": "application/pdf",
+            },
+        });
+    } catch (error) {
+        console.error("Error generating PDF:", error);
+        return NextResponse.json(
+            {
+                error: "Failed to generate PDF",
+                details:
+                    error instanceof Error ? error.message : "Unknown error",
+            },
+            { status: 500 },
+        );
+    }
+}
diff --git a/frontend/app/page.tsx b/frontend/app/page.tsx
index 25346cc..b735e8a 100644
--- a/frontend/app/page.tsx
+++ b/frontend/app/page.tsx
@@ -25,2870 +25,3602 @@ import GardnerStudio from "@/components/gardners/GardnerStudio";
 import { KnowledgeBase } from "@/components/tailwind/knowledge-base";
 import { FloatingDocumentActions } from "@/components/tailwind/document-toolbar";
 import { calculateTotalInvestment } from "@/lib/sow-utils";
-import { 
-  extractPricingFromContent, 
-  exportToExcel, 
-  exportToPDF,
-  parseSOWMarkdown,
-  cleanSOWContent
+import {
+    extractPricingFromContent,
+    exportToExcel,
+    exportToPDF,
+    parseSOWMarkdown,
+    cleanSOWContent,
 } from "@/lib/export-utils";
 import { anythingLLM } from "@/lib/anythingllm";
 import { ROLES } from "@/components/tailwind/extensions/editable-pricing-table";
 import { getWorkspaceForAgent } from "@/lib/workspace-config";
+import {
+    extractBusinessRulesFromPrompt,
+    UserBusinessRules,
+    formatBusinessRules,
+} from "@/lib/prompt-parser";
+import {
+    applyDataPrecedence,
+    logPrecedenceApplication,
+    AIGeneratedData,
+    extractServicesFromPrompt,
+} from "@/lib/data-precedence";
 
 // API key is now handled server-side in /api/chat route
 
 // ðŸŽ¯ UTILITY: Extract client/company name from user prompt
 const extractClientName = (prompt: string): string | null => {
-  // Common patterns for client mentions:
-  // "for ABC Company", "for Company XYZ", "client: ABC Corp", "ABC Corp needs", etc.
-  const patterns = [
-    /\bfor\s+([A-Z][A-Za-z0-9&\s]+(?:Corp|Corporation|Inc|LLC|Ltd|Company|Co|Group|Agency|Services|Solutions|Technologies)?)/i,
-    /\bclient:\s*([A-Z][A-Za-z0-9&\s]+)/i,
-    /\b([A-Z][A-Za-z0-9&\s]+(?:Corp|Corporation|Inc|LLC|Ltd|Company|Co|Group))\s+(?:needs|wants|requires)/i,
-    /\b([A-Z][A-Za-z0-9&\s]{2,30})\s+(?:integration|website|project|campaign|sow)/i,
-  ];
-
-  for (const pattern of patterns) {
-    const match = prompt.match(pattern);
-    if (match && match[1]) {
-      // Clean up the match
-      let name = match[1].trim();
-      // Remove trailing words that aren't part of company name
-      name = name.replace(/\s+(integration|website|project|campaign|sow|needs|wants|requires)$/i, '');
-      if (name.length > 2 && name.length < 50) {
-        return name;
-      }
+    // Common patterns for client mentions:
+    // "for ABC Company", "for Company XYZ", "client: ABC Corp", "ABC Corp needs", etc.
+    const patterns = [
+        /\bfor\s+([A-Z][A-Za-z0-9&\s]+(?:Corp|Corporation|Inc|LLC|Ltd|Company|Co|Group|Agency|Services|Solutions|Technologies)?)/i,
+        /\bclient:\s*([A-Z][A-Za-z0-9&\s]+)/i,
+        /\b([A-Z][A-Za-z0-9&\s]+(?:Corp|Corporation|Inc|LLC|Ltd|Company|Co|Group))\s+(?:needs|wants|requires)/i,
+        /\b([A-Z][A-Za-z0-9&\s]{2,30})\s+(?:integration|website|project|campaign|sow)/i,
+    ];
+
+    for (const pattern of patterns) {
+        const match = prompt.match(pattern);
+        if (match && match[1]) {
+            // Clean up the match
+            let name = match[1].trim();
+            // Remove trailing words that aren't part of company name
+            name = name.replace(
+                /\s+(integration|website|project|campaign|sow|needs|wants|requires)$/i,
+                "",
+            );
+            if (name.length > 2 && name.length < 50) {
+                return name;
+            }
+        }
     }
-  }
-  
-  return null;
+
+    return null;
 };
 
 // Helper function to convert markdown to Novel editor JSON format
 const convertMarkdownToNovelJSON = (markdown: string) => {
-  const lines = markdown.split('\n');
-  const content: any[] = [];
-  let i = 0;
-  let inTable = false;
-  let tableRows: string[] = [];
-
-  const parseTextWithFormatting = (text: string) => {
-    const parts: any[] = [];
-    let currentText = '';
-    let isBold = false;
-    let isItalic = false;
-    
-    for (let i = 0; i < text.length; i++) {
-      if (text.substring(i, i + 2) === '**') {
-        if (currentText) {
-          parts.push({ type: 'text', text: currentText, marks: isBold || isItalic ? [isBold ? { type: 'bold' } : { type: 'italic' }] : undefined });
-          currentText = '';
+    const lines = markdown.split("\n");
+    const content: any[] = [];
+    let i = 0;
+    let inTable = false;
+    let tableRows: string[] = [];
+
+    const parseTextWithFormatting = (text: string) => {
+        const parts: any[] = [];
+        let currentText = "";
+        let isBold = false;
+        let isItalic = false;
+
+        for (let i = 0; i < text.length; i++) {
+            if (text.substring(i, i + 2) === "**") {
+                if (currentText) {
+                    parts.push({
+                        type: "text",
+                        text: currentText,
+                        marks:
+                            isBold || isItalic
+                                ? [
+                                      isBold
+                                          ? { type: "bold" }
+                                          : { type: "italic" },
+                                  ]
+                                : undefined,
+                    });
+                    currentText = "";
+                }
+                isBold = !isBold;
+                i++;
+            } else if (text[i] === "*" || text[i] === "_") {
+                if (currentText) {
+                    parts.push({
+                        type: "text",
+                        text: currentText,
+                        marks:
+                            isBold || isItalic
+                                ? [
+                                      isBold
+                                          ? { type: "bold" }
+                                          : { type: "italic" },
+                                  ]
+                                : undefined,
+                    });
+                    currentText = "";
+                }
+                isItalic = !isItalic;
+            } else {
+                currentText += text[i];
+            }
         }
-        isBold = !isBold;
-        i++;
-      } else if (text[i] === '*' || text[i] === '_') {
+
         if (currentText) {
-          parts.push({ type: 'text', text: currentText, marks: isBold || isItalic ? [isBold ? { type: 'bold' } : { type: 'italic' }] : undefined });
-          currentText = '';
+            const marks = [];
+            if (isBold) marks.push({ type: "bold" });
+            if (isItalic) marks.push({ type: "italic" });
+            parts.push({
+                type: "text",
+                text: currentText,
+                marks: marks.length > 0 ? marks : undefined,
+            });
         }
-        isItalic = !isItalic;
-      } else {
-        currentText += text[i];
-      }
-    }
-    
-    if (currentText) {
-      const marks = [];
-      if (isBold) marks.push({ type: 'bold' });
-      if (isItalic) marks.push({ type: 'italic' });
-      parts.push({ type: 'text', text: currentText, marks: marks.length > 0 ? marks : undefined });
-    }
-    
-    return parts.length > 0 ? parts : [{ type: 'text', text: text }];
-  };
-
-  const processTable = (rows: string[]) => {
-    if (rows.length < 2) return null;
-    
-    const headerRow = rows[0].split('|').filter(cell => cell.trim() !== '').map(cell => cell.trim());
-    const dataRows = rows.slice(2).map(row => 
-      row.split('|').filter(cell => cell.trim() !== '').map(cell => cell.trim())
-    );
 
-    // Check if this is a pricing table (has Role, Hours, Rate columns)
-    const isPricingTable = headerRow.some(h => h.toLowerCase().includes('role')) &&
-                          headerRow.some(h => h.toLowerCase().includes('hours')) &&
-                          headerRow.some(h => h.toLowerCase().includes('rate'));
-
-    if (isPricingTable) {
-      // Find column indexes
-      const roleIdx = headerRow.findIndex(h => h.toLowerCase().includes('role'));
-      const descIdx = headerRow.findIndex(h => h.toLowerCase().includes('description'));
-      const hoursIdx = headerRow.findIndex(h => h.toLowerCase().includes('hours'));
-      const rateIdx = headerRow.findIndex(h => h.toLowerCase().includes('rate'));
-
-      // Helper function to match role name to ROLES list with better fuzzy matching
-      const matchRole = (roleName: string) => {
-        const cleanRoleName = roleName.trim().replace(/\s+/g, ' ');
-        
-        // 1. Try exact match first
-        const exactMatch = ROLES.find(r => r.name === cleanRoleName);
-        if (exactMatch) return { name: exactMatch.name, rate: exactMatch.rate };
-        
-        // 2. Try case-insensitive match
-        const caseInsensitiveMatch = ROLES.find(r => 
-          r.name.toLowerCase() === cleanRoleName.toLowerCase()
+        return parts.length > 0 ? parts : [{ type: "text", text: text }];
+    };
+
+    const processTable = (rows: string[]) => {
+        if (rows.length < 2) return null;
+
+        const headerRow = rows[0]
+            .split("|")
+            .filter((cell) => cell.trim() !== "")
+            .map((cell) => cell.trim());
+        const dataRows = rows.slice(2).map((row) =>
+            row
+                .split("|")
+                .filter((cell) => cell.trim() !== "")
+                .map((cell) => cell.trim()),
         );
-        if (caseInsensitiveMatch) return { name: caseInsensitiveMatch.name, rate: caseInsensitiveMatch.rate };
-        
-        // 3. Try splitting by hyphen and matching parts (e.g., "Tech - Producer" should match "Producer")
-        const parts = cleanRoleName.split(/\s*[-â€“â€”]\s*/);
-        if (parts.length > 1) {
-          for (const part of parts) {
-            const trimmedPart = part.trim();
-            if (trimmedPart.length > 2) {
-              const partMatch = ROLES.find(r => 
-                r.name.toLowerCase() === trimmedPart.toLowerCase() ||
-                r.name.toLowerCase().includes(trimmedPart.toLowerCase())
-              );
-              if (partMatch) return { name: partMatch.name, rate: partMatch.rate };
-            }
-          }
-        }
-        
-        // 4. Try fuzzy matching by looking for role keywords
-        const keywords = ['tech', 'producer', 'specialist', 'consultant', 'manager', 'coordinator', 'architect', 'designer', 'developer', 'strategist', 'account'];
-        for (const keyword of keywords) {
-          if (cleanRoleName.toLowerCase().includes(keyword)) {
-            const keywordMatch = ROLES.find(r => r.name.toLowerCase().includes(keyword));
-            if (keywordMatch) return { name: keywordMatch.name, rate: keywordMatch.rate };
-          }
+
+        // Check if this is a pricing table (has Role, Hours, Rate columns)
+        const isPricingTable =
+            headerRow.some((h) => h.toLowerCase().includes("role")) &&
+            headerRow.some((h) => h.toLowerCase().includes("hours")) &&
+            headerRow.some((h) => h.toLowerCase().includes("rate"));
+
+        if (isPricingTable) {
+            // Find column indexes
+            const roleIdx = headerRow.findIndex((h) =>
+                h.toLowerCase().includes("role"),
+            );
+            const descIdx = headerRow.findIndex((h) =>
+                h.toLowerCase().includes("description"),
+            );
+            const hoursIdx = headerRow.findIndex((h) =>
+                h.toLowerCase().includes("hours"),
+            );
+            const rateIdx = headerRow.findIndex((h) =>
+                h.toLowerCase().includes("rate"),
+            );
+
+            // Helper function to match role name to ROLES list with better fuzzy matching
+            const matchRole = (roleName: string) => {
+                const cleanRoleName = roleName.trim().replace(/\s+/g, " ");
+
+                // 1. Try exact match first
+                const exactMatch = ROLES.find((r) => r.name === cleanRoleName);
+                if (exactMatch)
+                    return { name: exactMatch.name, rate: exactMatch.rate };
+
+                // 2. Try case-insensitive match
+                const caseInsensitiveMatch = ROLES.find(
+                    (r) => r.name.toLowerCase() === cleanRoleName.toLowerCase(),
+                );
+                if (caseInsensitiveMatch)
+                    return {
+                        name: caseInsensitiveMatch.name,
+                        rate: caseInsensitiveMatch.rate,
+                    };
+
+                // 3. Try splitting by hyphen and matching parts (e.g., "Tech - Producer" should match "Producer")
+                const parts = cleanRoleName.split(/\s*[-â€“â€”]\s*/);
+                if (parts.length > 1) {
+                    for (const part of parts) {
+                        const trimmedPart = part.trim();
+                        if (trimmedPart.length > 2) {
+                            const partMatch = ROLES.find(
+                                (r) =>
+                                    r.name.toLowerCase() ===
+                                        trimmedPart.toLowerCase() ||
+                                    r.name
+                                        .toLowerCase()
+                                        .includes(trimmedPart.toLowerCase()),
+                            );
+                            if (partMatch)
+                                return {
+                                    name: partMatch.name,
+                                    rate: partMatch.rate,
+                                };
+                        }
+                    }
+                }
+
+                // 4. Try fuzzy matching by looking for role keywords
+                const keywords = [
+                    "tech",
+                    "producer",
+                    "specialist",
+                    "consultant",
+                    "manager",
+                    "coordinator",
+                    "architect",
+                    "designer",
+                    "developer",
+                    "strategist",
+                    "account",
+                ];
+                for (const keyword of keywords) {
+                    if (cleanRoleName.toLowerCase().includes(keyword)) {
+                        const keywordMatch = ROLES.find((r) =>
+                            r.name.toLowerCase().includes(keyword),
+                        );
+                        if (keywordMatch)
+                            return {
+                                name: keywordMatch.name,
+                                rate: keywordMatch.rate,
+                            };
+                    }
+                }
+
+                // 5. Try partial match (contains)
+                const partialMatch = ROLES.find(
+                    (r) =>
+                        r.name
+                            .toLowerCase()
+                            .includes(cleanRoleName.toLowerCase()) ||
+                        cleanRoleName
+                            .toLowerCase()
+                            .includes(r.name.toLowerCase()),
+                );
+                if (partialMatch)
+                    return { name: partialMatch.name, rate: partialMatch.rate };
+
+                // 6. Default: use the role name as-is but try to extract rate
+                const rateMatch = roleName.match(/\$?(\d+)/);
+                return {
+                    name: cleanRoleName,
+                    rate: rateMatch ? parseFloat(rateMatch[1]) : 0,
+                };
+            };
+
+            // Convert data rows to pricing row format
+            const pricingRows = dataRows.map((row) => {
+                const rawRole = row[roleIdx] || "";
+                const matchedRole = matchRole(rawRole);
+                const specifiedRate = row[rateIdx]
+                    ? parseFloat(row[rateIdx]?.replace(/[^0-9.]/g, "") || "0")
+                    : null;
+
+                console.log(
+                    `ðŸ’¼ [Role Match] "${rawRole}" â†’ "${matchedRole.name}" @ $${matchedRole.rate}`,
+                );
+
+                return {
+                    role: matchedRole.name, // Use matched role name from ROLES list
+                    description: row[descIdx] || "",
+                    hours: parseFloat(
+                        row[hoursIdx]?.replace(/[^0-9.]/g, "") || "0",
+                    ),
+                    rate: specifiedRate || matchedRole.rate, // Use specified rate or matched role's rate
+                };
+            });
+
+            // Return editable pricing table node
+            return {
+                type: "editablePricingTable",
+                attrs: {
+                    rows: pricingRows,
+                    discount: 0,
+                },
+            };
         }
-        
-        // 5. Try partial match (contains)
-        const partialMatch = ROLES.find(r => 
-          r.name.toLowerCase().includes(cleanRoleName.toLowerCase()) ||
-          cleanRoleName.toLowerCase().includes(r.name.toLowerCase())
-        );
-        if (partialMatch) return { name: partialMatch.name, rate: partialMatch.rate };
-        
-        // 6. Default: use the role name as-is but try to extract rate
-        const rateMatch = roleName.match(/\$?(\d+)/);
-        return { 
-          name: cleanRoleName, 
-          rate: rateMatch ? parseFloat(rateMatch[1]) : 0 
-        };
-      };
-
-      // Convert data rows to pricing row format
-      const pricingRows = dataRows.map(row => {
-        const rawRole = row[roleIdx] || '';
-        const matchedRole = matchRole(rawRole);
-        const specifiedRate = row[rateIdx] ? parseFloat(row[rateIdx]?.replace(/[^0-9.]/g, '') || '0') : null;
-        
-        console.log(`ðŸ’¼ [Role Match] "${rawRole}" â†’ "${matchedRole.name}" @ $${matchedRole.rate}`);
-        
-        return {
-          role: matchedRole.name, // Use matched role name from ROLES list
-          description: row[descIdx] || '',
-          hours: parseFloat(row[hoursIdx]?.replace(/[^0-9.]/g, '') || '0'),
-          rate: specifiedRate || matchedRole.rate, // Use specified rate or matched role's rate
+
+        // Regular table
+        const tableNode = {
+            type: "table",
+            content: [
+                {
+                    type: "tableRow",
+                    content: headerRow.map((header) => ({
+                        type: "tableHeader",
+                        content: [
+                            {
+                                type: "paragraph",
+                                content: parseTextWithFormatting(header),
+                            },
+                        ],
+                    })),
+                },
+                ...dataRows.map((row) => ({
+                    type: "tableRow",
+                    content: row.map((cell) => ({
+                        type: "tableCell",
+                        content: [
+                            {
+                                type: "paragraph",
+                                content: parseTextWithFormatting(cell),
+                            },
+                        ],
+                    })),
+                })),
+            ],
         };
-      });
-
-      // Return editable pricing table node
-      return {
-        type: 'editablePricingTable',
-        attrs: {
-          rows: pricingRows,
-          discount: 0,
-        },
-      };
-    }
 
-    // Regular table
-    const tableNode = {
-      type: 'table',
-      content: [
-        {
-          type: 'tableRow',
-          content: headerRow.map(header => ({
-            type: 'tableHeader',
-            content: [{
-              type: 'paragraph',
-              content: parseTextWithFormatting(header)
-            }]
-          }))
-        },
-        ...dataRows.map(row => ({
-          type: 'tableRow',
-          content: row.map(cell => ({
-            type: 'tableCell',
-            content: [{
-              type: 'paragraph',
-              content: parseTextWithFormatting(cell)
-            }]
-          }))
-        }))
-      ]
+        return tableNode;
     };
-    
-    return tableNode;
-  };
-
-  while (i < lines.length) {
-    const line = lines[i];
-
-    if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('---')) {
-      // Start of table
-      inTable = true;
-      tableRows = [line];
-      i++;
-      continue;
-    } else if (inTable && line.includes('|')) {
-      tableRows.push(line);
-      i++;
-      continue;
-    } else if (inTable && !line.includes('|')) {
-      // End of table
-      const tableNode = processTable(tableRows);
-      if (tableNode) content.push(tableNode);
-      inTable = false;
-      tableRows = [];
-    }
 
-    if (!inTable) {
-      if (line.startsWith('# ')) {
-        content.push({
-          type: 'heading',
-          attrs: { level: 1 },
-          content: parseTextWithFormatting(line.substring(2))
-        });
-      } else if (line.startsWith('## ')) {
-        content.push({
-          type: 'heading',
-          attrs: { level: 2 },
-          content: parseTextWithFormatting(line.substring(3))
-        });
-      } else if (line.startsWith('### ')) {
-        content.push({
-          type: 'heading',
-          attrs: { level: 3 },
-          content: parseTextWithFormatting(line.substring(4))
-        });
-      } else if (line.startsWith('- ') || line.startsWith('* ')) {
-        content.push({
-          type: 'bulletList',
-          content: [{
-            type: 'listItem',
-            content: [{
-              type: 'paragraph',
-              content: parseTextWithFormatting(line.substring(2))
-            }]
-          }]
-        });
-      } else if (line.startsWith('---')) {
-        content.push({
-          type: 'horizontalRule'
-        });
-      } else if (line.trim() === '') {
-        // Skip empty lines
-      } else if (line.trim() !== '') {
-        content.push({
-          type: 'paragraph',
-          content: parseTextWithFormatting(line)
-        });
-      }
-    }
+    while (i < lines.length) {
+        const line = lines[i];
+
+        if (
+            line.includes("|") &&
+            i + 1 < lines.length &&
+            lines[i + 1].includes("---")
+        ) {
+            // Start of table
+            inTable = true;
+            tableRows = [line];
+            i++;
+            continue;
+        } else if (inTable && line.includes("|")) {
+            tableRows.push(line);
+            i++;
+            continue;
+        } else if (inTable && !line.includes("|")) {
+            // End of table
+            const tableNode = processTable(tableRows);
+            if (tableNode) content.push(tableNode);
+            inTable = false;
+            tableRows = [];
+        }
+
+        if (!inTable) {
+            if (line.startsWith("# ")) {
+                content.push({
+                    type: "heading",
+                    attrs: { level: 1 },
+                    content: parseTextWithFormatting(line.substring(2)),
+                });
+            } else if (line.startsWith("## ")) {
+                content.push({
+                    type: "heading",
+                    attrs: { level: 2 },
+                    content: parseTextWithFormatting(line.substring(3)),
+                });
+            } else if (line.startsWith("### ")) {
+                content.push({
+                    type: "heading",
+                    attrs: { level: 3 },
+                    content: parseTextWithFormatting(line.substring(4)),
+                });
+            } else if (line.startsWith("- ") || line.startsWith("* ")) {
+                content.push({
+                    type: "bulletList",
+                    content: [
+                        {
+                            type: "listItem",
+                            content: [
+                                {
+                                    type: "paragraph",
+                                    content: parseTextWithFormatting(
+                                        line.substring(2),
+                                    ),
+                                },
+                            ],
+                        },
+                    ],
+                });
+            } else if (line.startsWith("---")) {
+                content.push({
+                    type: "horizontalRule",
+                });
+            } else if (line.trim() === "") {
+                // Skip empty lines
+            } else if (line.trim() !== "") {
+                content.push({
+                    type: "paragraph",
+                    content: parseTextWithFormatting(line),
+                });
+            }
+        }
 
-    i++;
-  }
+        i++;
+    }
 
-  // Process any remaining table
-  if (inTable && tableRows.length > 0) {
-    const tableNode = processTable(tableRows);
-    if (tableNode) content.push(tableNode);
-  }
+    // Process any remaining table
+    if (inTable && tableRows.length > 0) {
+        const tableNode = processTable(tableRows);
+        if (tableNode) content.push(tableNode);
+    }
 
-  return { type: 'doc', content };
+    return { type: "doc", content };
 };
 
 interface Document {
-  id: string;
-  title: string;
-  content: any;
-  folderId?: string;
-  workspaceSlug?: string;
-  threadSlug?: string;
-  threadId?: string;
-  syncedAt?: string;
-  totalInvestment?: number;
-  workType?: 'project' | 'audit' | 'retainer'; // ðŸŽ¯ SOW type determined by Architect AI
+    id: string;
+    title: string;
+    content: any;
+    folderId?: string;
+    workspaceSlug?: string;
+    threadSlug?: string;
+    threadId?: string;
+    syncedAt?: string;
+    totalInvestment?: number;
+    workType?: "project" | "audit" | "retainer"; // ðŸŽ¯ SOW type determined by Architect AI
 }
 
 interface Folder {
-  id: string;
-  name: string;
-  parentId?: string;
-  workspaceSlug?: string;
-  workspaceId?: string;
-  embedId?: number;  // Numeric ID from AnythingLLM
-  syncedAt?: string;
+    id: string;
+    name: string;
+    parentId?: string;
+    workspaceSlug?: string;
+    workspaceId?: string;
+    embedId?: number; // Numeric ID from AnythingLLM
+    syncedAt?: string;
 }
 
 interface Agent {
-  id: string;
-  name: string;
-  systemPrompt: string;
-  model: string;
-  useAnythingLLM?: boolean; // If true, use AnythingLLM's configured provider
+    id: string;
+    name: string;
+    systemPrompt: string;
+    model: string;
+    useAnythingLLM?: boolean; // If true, use AnythingLLM's configured provider
 }
 
 interface ChatMessage {
-  id: string;
-  role: 'user' | 'assistant';
-  content: string;
-  timestamp: number;
+    id: string;
+    role: "user" | "assistant";
+    content: string;
+    timestamp: number;
 }
 
 interface SOW {
-  id: string;
-  name: string;
-  workspaceId: string;
+    id: string;
+    name: string;
+    workspaceId: string;
 }
 
 interface Workspace {
-  id: string;
-  name: string;
-  sows: SOW[];
-  workspace_slug?: string;
+    id: string;
+    name: string;
+    sows: SOW[];
+    workspace_slug?: string;
 }
 
 // ðŸŽ¯ Extract SOW work type from AI response
 // The Architect classifies SOWs into 3 types: Standard Project, Audit/Strategy, or Retainer
-const extractWorkType = (content: string): 'project' | 'audit' | 'retainer' => {
-  if (!content) return 'project';
-  
-  const lowerContent = content.toLowerCase();
-  
-  // Check for Retainer patterns
-  if (
-    lowerContent.includes('retainer') ||
-    lowerContent.includes('monthly support') ||
-    lowerContent.includes('ongoing support') ||
-    lowerContent.includes('recurring deliverables') ||
-    lowerContent.includes('monthly fee') ||
-    (lowerContent.includes('month') && lowerContent.includes('support'))
-  ) {
-    console.log('ðŸŽ¯ [Work Type] Detected: Retainer');
-    return 'retainer';
-  }
-  
-  // Check for Audit/Strategy patterns
-  if (
-    lowerContent.includes('audit') ||
-    lowerContent.includes('assessment') ||
-    lowerContent.includes('strategy') ||
-    lowerContent.includes('recommendations') ||
-    lowerContent.includes('analysis') ||
-    (lowerContent.includes('review') && lowerContent.includes('implementation'))
-  ) {
-    console.log('ðŸŽ¯ [Work Type] Detected: Audit/Strategy');
-    return 'audit';
-  }
-  
-  // Default to Standard Project
-  console.log('ðŸŽ¯ [Work Type] Detected: Standard Project');
-  return 'project';
+const extractWorkType = (content: string): "project" | "audit" | "retainer" => {
+    if (!content) return "project";
+
+    const lowerContent = content.toLowerCase();
+
+    // Check for Retainer patterns
+    if (
+        lowerContent.includes("retainer") ||
+        lowerContent.includes("monthly support") ||
+        lowerContent.includes("ongoing support") ||
+        lowerContent.includes("recurring deliverables") ||
+        lowerContent.includes("monthly fee") ||
+        (lowerContent.includes("month") && lowerContent.includes("support"))
+    ) {
+        console.log("ðŸŽ¯ [Work Type] Detected: Retainer");
+        return "retainer";
+    }
+
+    // Check for Audit/Strategy patterns
+    if (
+        lowerContent.includes("audit") ||
+        lowerContent.includes("assessment") ||
+        lowerContent.includes("strategy") ||
+        lowerContent.includes("recommendations") ||
+        lowerContent.includes("analysis") ||
+        (lowerContent.includes("review") &&
+            lowerContent.includes("implementation"))
+    ) {
+        console.log("ðŸŽ¯ [Work Type] Detected: Audit/Strategy");
+        return "audit";
+    }
+
+    // Default to Standard Project
+    console.log("ðŸŽ¯ [Work Type] Detected: Standard Project");
+    return "project";
 };
 
 export default function Page() {
-  const [mounted, setMounted] = useState(false);
-  const [documents, setDocuments] = useState<Document[]>([]);
-  const [folders, setFolders] = useState<Folder[]>([]);
-  const [currentDocId, setCurrentDocId] = useState<string | null>(null);
-  const [sidebarOpen, setSidebarOpen] = useState(true);
-  const [agentSidebarOpen, setAgentSidebarOpen] = useState(true);
-  const [agents, setAgents] = useState<Agent[]>([]);
-  const [currentAgentId, setCurrentAgentId] = useState<string | null>(null);
-  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
-  const [isChatLoading, setIsChatLoading] = useState(false);
-  const [streamingMessageId, setStreamingMessageId] = useState<string | null>(null); // Track which message is streaming
-  const [showSendModal, setShowSendModal] = useState(false);
-  const [showShareModal, setShowShareModal] = useState(false);
-  const [shareModalData, setShareModalData] = useState<{
-    shareLink: string;
-    documentTitle: string;
-    shareCount?: number;
-    firstShared?: string;
-    lastShared?: string;
-  } | null>(null);
-  const [showGuidedSetup, setShowGuidedSetup] = useState(false);
-  // TEMP: Hide dashboard, default to editor view
-  const [viewMode, setViewMode] = useState<'editor' | 'dashboard' | 'gardner-studio' | 'ai-management'>('editor'); // TEMP: Hide dashboard, default to editor
-  
-  // Workspace & SOW state (NEW) - Start empty, load from AnythingLLM
-  const [workspaces, setWorkspaces] = useState<Workspace[]>([]);
-  const [currentWorkspaceId, setCurrentWorkspaceId] = useState<string>('');
-  const [currentSOWId, setCurrentSOWId] = useState<string | null>(null);
-  const editorRef = useRef<any>(null);
-
-  // Workspace creation progress state (NEW)
-  const [workspaceCreationProgress, setWorkspaceCreationProgress] = useState<{
-    isOpen: boolean;
-    workspaceName: string;
-    currentStep: number;
-    completedSteps: number[];
-  }>({
-    isOpen: false,
-    workspaceName: '',
-    currentStep: 0,
-    completedSteps: [],
-  });
-
-  // Onboarding state (NEW)
-  const [showOnboarding, setShowOnboarding] = useState(false);
-
-  // OAuth state for Google Sheets
-  const [isOAuthAuthorized, setIsOAuthAuthorized] = useState(false);
-  const [oauthAccessToken, setOauthAccessToken] = useState<string>('');
-
-  // Dashboard AI workspace selector state - Master dashboard is the default
-  const [dashboardChatTarget, setDashboardChatTarget] = useState<string>('sow-master-dashboard');
-  const [availableWorkspaces, setAvailableWorkspaces] = useState<Array<{slug: string, name: string}>>([
-    { slug: 'sow-master-dashboard', name: 'ðŸŽ¯ All SOWs (Master)' }
-  ]);
-
-  // Initialize master dashboard on app load
-  useEffect(() => {
-    const initDashboard = async () => {
-      try {
-        await anythingLLM.getOrCreateMasterDashboard();
-        console.log('âœ… Master SOW Dashboard initialized');
-      } catch (error) {
-        console.error('âŒ Failed to initialize dashboard:', error);
-      }
-    };
-    initDashboard();
-  }, []);
-
-  // Check for OAuth callback on mount
-  useEffect(() => {
-    const params = new URLSearchParams(window.location.search);
-    const oauthToken = params.get('oauth_token');
-    const error = params.get('oauth_error');
-
-    if (error) {
-      toast.error(`OAuth error: ${error}`);
-      // Clean up URL
-      window.history.replaceState({}, document.title, window.location.pathname);
-      return;
-    }
+    const [mounted, setMounted] = useState(false);
+    const [documents, setDocuments] = useState<Document[]>([]);
+    const [folders, setFolders] = useState<Folder[]>([]);
+    const [currentDocId, setCurrentDocId] = useState<string | null>(null);
+    const [sidebarOpen, setSidebarOpen] = useState(true);
+    const [agentSidebarOpen, setAgentSidebarOpen] = useState(true);
+    const [agents, setAgents] = useState<Agent[]>([]);
+    const [currentAgentId, setCurrentAgentId] = useState<string | null>(null);
+    const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
+    const [isChatLoading, setIsChatLoading] = useState(false);
+    const [streamingMessageId, setStreamingMessageId] = useState<string | null>(
+        null,
+    ); // Track which message is streaming
+    const [showSendModal, setShowSendModal] = useState(false);
+    const [showShareModal, setShowShareModal] = useState(false);
+    const [shareModalData, setShareModalData] = useState<{
+        shareLink: string;
+        documentTitle: string;
+        shareCount?: number;
+        firstShared?: string;
+        lastShared?: string;
+    } | null>(null);
+    const [showGuidedSetup, setShowGuidedSetup] = useState(false);
+    // TEMP: Hide dashboard, default to editor view
+    const [viewMode, setViewMode] = useState<
+        "editor" | "dashboard" | "gardner-studio" | "ai-management"
+    >("editor"); // TEMP: Hide dashboard, default to editor
+
+    // Workspace & SOW state (NEW) - Start empty, load from AnythingLLM
+    const [workspaces, setWorkspaces] = useState<Workspace[]>([]);
+    const [currentWorkspaceId, setCurrentWorkspaceId] = useState<string>("");
+    const [currentSOWId, setCurrentSOWId] = useState<string | null>(null);
+    const editorRef = useRef<any>(null);
+
+    // Workspace creation progress state (NEW)
+    const [workspaceCreationProgress, setWorkspaceCreationProgress] = useState<{
+        isOpen: boolean;
+        workspaceName: string;
+        currentStep: number;
+        completedSteps: number[];
+    }>({
+        isOpen: false,
+        workspaceName: "",
+        currentStep: 0,
+        completedSteps: [],
+    });
 
-    if (oauthToken) {
-      console.log('âœ… OAuth token received from callback');
-      setOauthAccessToken(oauthToken);
-      setIsOAuthAuthorized(true);
-      toast.success('âœ… Google authorized! Will create GSheet once document loads...');
-      
-      // Clean up URL
-      window.history.replaceState({}, document.title, window.location.pathname);
-    }
-  }, []);
-
-  // Auto-trigger sheet creation when BOTH OAuth token and document are ready
-  useEffect(() => {
-    if (oauthAccessToken && isOAuthAuthorized && currentDocId && documents.length > 0) {
-      const doc = documents.find(d => d.id === currentDocId);
-      if (doc) {
-        console.log('ðŸš€ Both OAuth token and document ready! Creating GSheet for:', doc.title);
-        createGoogleSheet(oauthAccessToken);
-        // Clear the OAuth state to prevent re-triggering
-        setIsOAuthAuthorized(false);
-      }
-    }
-  }, [oauthAccessToken, isOAuthAuthorized, currentDocId, documents]);
-
-  // Fetch available workspaces for dashboard chat selector from loaded workspaces
-  useEffect(() => {
-    // Build workspace list: Master dashboard + client workspaces
-    const workspaceList = [
-      { slug: 'sow-master-dashboard', name: 'ðŸŽ¯ All SOWs (Master)' },
-      ...workspaces
-        .filter(ws => ws.workspace_slug) // Only include workspaces with workspace_slug
-        .map(ws => ({
-          slug: ws.workspace_slug || '', // Use workspace_slug
-          name: `ðŸ“ ${ws.name}` // Prefix with folder icon
-        }))
-    ];
-    
-    setAvailableWorkspaces(workspaceList);
-    console.log('ðŸ“‹ Available workspaces for dashboard chat:', workspaceList);
-  }, [workspaces]); // Re-run when workspaces change
-
-  // Fix hydration by setting mounted state
-  useEffect(() => {
-    setMounted(true);
-  }, []);
-
-  useEffect(() => {
-    console.log('Loading workspace data, mounted:', mounted);
-    if (!mounted) return;
-    
-    const loadData = async () => {
-      console.log('Loading folders and SOWs from database...');
-      const savedCurrent = localStorage.getItem("currentDocId");
-      const hasCompletedSetup = localStorage.getItem("sow-guided-setup-completed");
-      
-      try {
-        // LOAD FOLDERS FROM DATABASE
-        const foldersResponse = await fetch('/api/folders');
-        const foldersData = await foldersResponse.json();
-        console.log('Loaded folders from database:', foldersData.length);
-        
-        // LOAD SOWS FROM DATABASE
-        const sowsResponse = await fetch('/api/sow/list');
-        const { sows: dbSOWs } = await sowsResponse.json();
-        console.log('Loaded SOWs from database:', dbSOWs.length);
-        
-        const workspacesWithSOWs: Workspace[] = [];
-        const documentsFromDB: Document[] = [];
-        const foldersFromDB: Folder[] = [];
-        
-        // Create workspace objects with SOWs from database
-        for (const folder of foldersData) {
-          console.log(`Processing folder: ${folder.name} (ID: ${folder.id})`);
-          
-          // Find SOWs that belong to this folder
-          const folderSOWs = dbSOWs.filter((sow: any) => sow.folder_id === folder.id);
-          
-          const sows: SOW[] = folderSOWs.map((sow: any) => ({
-            id: sow.id,
-            name: sow.title || 'Untitled SOW',
-            workspaceId: folder.id,
-          }));
-          
-          console.log(`   Found ${sows.length} SOWs in this folder`);
-          
-          // Add to workspaces array
-          workspacesWithSOWs.push({
-            id: folder.id,
-            name: folder.name,
-            sows: sows,
-            workspace_slug: folder.workspace_slug,
-          });
-          
-          // Add to folders array
-          foldersFromDB.push({
-            id: folder.id,
-            name: folder.name,
-            workspaceSlug: folder.workspace_slug,
-            workspaceId: folder.workspace_id,
-            embedId: folder.embed_id,
-            syncedAt: folder.updated_at || folder.created_at,
-          });
-          
-          // Create document objects for each SOW from database
-          for (const sow of folderSOWs) {
-            // Parse content if it's a JSON string, otherwise use as-is
-            let parsedContent = defaultEditorContent;
-            if (sow.content) {
-              try {
-                parsedContent = typeof sow.content === 'string' 
-                  ? JSON.parse(sow.content) 
-                  : sow.content;
-              } catch (e) {
-                console.warn('Failed to parse SOW content:', sow.id);
-                parsedContent = defaultEditorContent;
-              }
+    // Onboarding state (NEW)
+    const [showOnboarding, setShowOnboarding] = useState(false);
+
+    // OAuth state for Google Sheets
+    const [isOAuthAuthorized, setIsOAuthAuthorized] = useState(false);
+    const [oauthAccessToken, setOauthAccessToken] = useState<string>("");
+
+    // Dashboard AI workspace selector state - Master dashboard is the default
+    const [dashboardChatTarget, setDashboardChatTarget] = useState<string>(
+        "sow-master-dashboard",
+    );
+    const [availableWorkspaces, setAvailableWorkspaces] = useState<
+        Array<{ slug: string; name: string }>
+    >([{ slug: "sow-master-dashboard", name: "ðŸŽ¯ All SOWs (Master)" }]);
+
+    // Initialize master dashboard on app load
+    useEffect(() => {
+        const initDashboard = async () => {
+            try {
+                await anythingLLM.getOrCreateMasterDashboard();
+                console.log("âœ… Master SOW Dashboard initialized");
+            } catch (error) {
+                console.error("âŒ Failed to initialize dashboard:", error);
             }
-            
-            documentsFromDB.push({
-              id: sow.id,
-              title: sow.title || 'Untitled SOW',
-              content: parsedContent,
-              folderId: folder.id,
-              workspaceSlug: folder.workspace_slug,
-              threadSlug: sow.thread_slug || undefined, // ðŸ§µ AnythingLLM thread UUID (NOT sow.id!)
-              syncedAt: sow.updated_at,
-            });
-          }
-        }
-        
-        console.log('Total workspaces loaded:', workspacesWithSOWs.length);
-        console.log('Total SOWs loaded:', documentsFromDB.length);
-        
-        // Update state
-        setWorkspaces(workspacesWithSOWs);
-        setFolders(foldersFromDB);
-        setDocuments(documentsFromDB);
-        
-        // Set current workspace to first one if available
-        // BUT: Don't auto-select a SOW - let user click from dashboard
-        if (workspacesWithSOWs.length > 0 && !currentWorkspaceId) {
-          setCurrentWorkspaceId(workspacesWithSOWs[0].id);
-          // Removed: Don't auto-select first SOW - user should manually select from dashboard
-          // This provides a better UX where dashboard is the entry point
-        }
-        
-        // ðŸŽ“ Show onboarding if no workspaces (and not seen before)
-        const hasSeenOnboarding = localStorage.getItem('hasSeenOnboarding') === 'true';
-        if (workspacesWithSOWs.length === 0 && !hasSeenOnboarding) {
-          setTimeout(() => {
-            setShowOnboarding(true);
-            localStorage.setItem('hasSeenOnboarding', 'true');
-          }, 500);
+        };
+        initDashboard();
+    }, []);
+
+    // Check for OAuth callback on mount
+    useEffect(() => {
+        const params = new URLSearchParams(window.location.search);
+        const oauthToken = params.get("oauth_token");
+        const error = params.get("oauth_error");
+
+        if (error) {
+            toast.error(`OAuth error: ${error}`);
+            // Clean up URL
+            window.history.replaceState(
+                {},
+                document.title,
+                window.location.pathname,
+            );
+            return;
         }
 
-        // Show guided setup if no workspaces
-        if (!hasCompletedSetup && workspacesWithSOWs.length === 0) {
-          setTimeout(() => setShowGuidedSetup(true), 1000);
+        if (oauthToken) {
+            console.log("âœ… OAuth token received from callback");
+            setOauthAccessToken(oauthToken);
+            setIsOAuthAuthorized(true);
+            toast.success(
+                "âœ… Google authorized! Will create GSheet once document loads...",
+            );
+
+            // Clean up URL
+            window.history.replaceState(
+                {},
+                document.title,
+                window.location.pathname,
+            );
         }
-        
-      } catch (error) {
-        console.error('Error loading data:', error);
-        toast.error('Failed to load workspaces and SOWs');
-      }
-      
-      if (savedCurrent) {
-        setCurrentDocId(savedCurrent);
-      }
-    };
-    
-    loadData();
-  }, [mounted]);
-
-  // Note: SOWs are now saved to database via API calls, not localStorage
-
-  // âœ¨ NEW: When currentSOWId changes, load the corresponding document and switch to editor view
-  useEffect(() => {
-    if (!currentSOWId) return;
-    
-    console.log('ðŸ“„ Loading document for SOW:', currentSOWId);
-    
-    // Find the document in the documents array
-    const doc = documents.find(d => d.id === currentSOWId);
-    
-    if (doc) {
-      console.log('âœ… Found document:', doc.title);
-      setCurrentDocId(doc.id);
-      setViewMode('editor'); // Switch to editor view
-      
-      // ðŸ§µ Load chat history from AnythingLLM thread
-      const loadChatHistory = async () => {
-        if (doc.threadSlug) {
-          try {
-            console.log('ðŸ’¬ Loading chat history for thread:', doc.threadSlug);
-            // ðŸŽ¯ Use the workspace where the SOW was created (where its thread lives)
-            const history = await anythingLLM.getThreadChats(doc.workspaceSlug || 'gen-the-architect', doc.threadSlug);
-            
-            if (history && history.length > 0) {
-              // Convert AnythingLLM history format to our ChatMessage format
-              const messages: ChatMessage[] = history.map((msg: any) => ({
-                id: `msg${Date.now()}-${Math.random()}`,
-                role: msg.role === 'user' ? 'user' : 'assistant',
-                content: msg.content,
-                timestamp: Date.now(),
-              }));
-              
-              console.log(`âœ… Loaded ${messages.length} messages from thread`);
-              setChatMessages(messages);
-            } else {
-              console.log('â„¹ï¸ No chat history found for this SOW');
-              setChatMessages([]);
+    }, []);
+
+    // Auto-trigger sheet creation when BOTH OAuth token and document are ready
+    useEffect(() => {
+        if (
+            oauthAccessToken &&
+            isOAuthAuthorized &&
+            currentDocId &&
+            documents.length > 0
+        ) {
+            const doc = documents.find((d) => d.id === currentDocId);
+            if (doc) {
+                console.log(
+                    "ðŸš€ Both OAuth token and document ready! Creating GSheet for:",
+                    doc.title,
+                );
+                createGoogleSheet(oauthAccessToken);
+                // Clear the OAuth state to prevent re-triggering
+                setIsOAuthAuthorized(false);
             }
-          } catch (error) {
-            console.error('âŒ Failed to load chat history:', error);
-            setChatMessages([]);
-          }
-        } else {
-          console.log('â„¹ï¸ No thread associated with this SOW, clearing chat');
-          setChatMessages([]);
-        }
-      };
-      
-      loadChatHistory();
-    } else {
-      console.warn('âš ï¸ Document not found for SOW:', currentSOWId);
-    }
-  }, [currentSOWId, documents]);
-
-  // Auto-save SOW content to database with debouncing
-  useEffect(() => {
-    // Find current doc in documents array
-    const currentDoc = documents.find(d => d.id === currentDocId);
-    if (!currentDocId || !currentDoc?.content) return;
-
-    const autoSaveTimer = setTimeout(async () => {
-      try {
-        const response = await fetch(`/api/sow/${currentDocId}`, {
-          method: 'PUT',
-          headers: { 'Content-Type': 'application/json' },
-          body: JSON.stringify({
-            content: currentDoc.content,
-            title: currentDoc.title,
-          }),
-        });
-
-        if (response.ok) {
-          console.log('ðŸ’¾ Auto-saved SOW:', currentDocId);
-        } else {
-          console.warn('âš ï¸ Auto-save failed for SOW:', currentDocId);
         }
-      } catch (error) {
-        console.error('âŒ Error auto-saving SOW:', error);
-      }
-    }, 2000); // Save after 2 seconds of inactivity
-
-    return () => clearTimeout(autoSaveTimer);
-  }, [currentDocId, documents]);
-
-  useEffect(() => {
-    if (currentDocId) {
-      localStorage.setItem("currentDocId", currentDocId);
-    }
-  }, [currentDocId]);
-
-  useEffect(() => {
-    // ðŸŒ± Load GARDNERS from AnythingLLM (not old agents table!)
-    const loadGardnersAsAgents = async () => {
-      try {
-        console.log('ðŸŒ± Loading Gardners from AnythingLLM...');
-        const response = await fetch('/api/gardners/list');
-        if (!response.ok) throw new Error('Failed to load Gardners');
-        
-        const { gardners } = await response.json();
-        console.log(`âœ… Loaded ${gardners.length} Gardners:`, gardners.map((g: any) => g.name));
-        
-        // Convert Gardners to Agent format for compatibility
-        const gardnerAgents: Agent[] = gardners.map((gardner: any) => ({
-          id: gardner.slug,
-          name: gardner.name,
-          systemPrompt: gardner.systemPrompt || '',
-          model: 'anythingllm', // All Gardners use AnythingLLM
-        }));
-        
-        setAgents(gardnerAgents);
-        
-        // Set default to "GEN - The Architect" (priority), then any gardner with "gen", then first available
-        const genArchitect = gardnerAgents.find(a => 
-          a.name === 'GEN - The Architect' || a.id === 'gen-the-architect'
+    }, [oauthAccessToken, isOAuthAuthorized, currentDocId, documents]);
+
+    // Fetch available workspaces for dashboard chat selector from loaded workspaces
+    useEffect(() => {
+        // Build workspace list: Master dashboard + client workspaces
+        const workspaceList = [
+            { slug: "sow-master-dashboard", name: "ðŸŽ¯ All SOWs (Master)" },
+            ...workspaces
+                .filter((ws) => ws.workspace_slug) // Only include workspaces with workspace_slug
+                .map((ws) => ({
+                    slug: ws.workspace_slug || "", // Use workspace_slug
+                    name: `ðŸ“ ${ws.name}`, // Prefix with folder icon
+                })),
+        ];
+
+        setAvailableWorkspaces(workspaceList);
+        console.log(
+            "ðŸ“‹ Available workspaces for dashboard chat:",
+            workspaceList,
         );
-        const anyGenGardner = gardnerAgents.find(a => a.id.includes('gen'));
-        const defaultAgentId = genArchitect?.id || anyGenGardner?.id || gardnerAgents[0]?.id || 'gen-the-architect';
-        
-        console.log(`ðŸŽ¯ [Agent Selection] Default agent set to: ${defaultAgentId}`);
-        
-        // Load current agent preference from database
-        const prefResponse = await fetch('/api/preferences/current_agent_id');
-        if (prefResponse.ok) {
-          const { value } = await prefResponse.json();
-          setCurrentAgentId(value || defaultAgentId);
-        } else {
-          setCurrentAgentId(defaultAgentId);
-        }
-        
-      } catch (error) {
-        console.error('âŒ Failed to load Gardners:', error);
-        // Fallback: show empty state
-        setAgents([]);
-        setCurrentAgentId(null);
-      }
-    };
-    
-    loadGardnersAsAgents();
-  }, []);
-
-  // Save current agent preference to database
-  useEffect(() => {
-    if (currentAgentId) {
-      fetch('/api/preferences/current_agent_id', {
-        method: 'PUT',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({ value: currentAgentId })
-      }).catch(err => console.error('Failed to save agent preference:', err));
-    }
-  }, [currentAgentId]);
+    }, [workspaces]); // Re-run when workspaces change
+
+    // Fix hydration by setting mounted state
+    useEffect(() => {
+        setMounted(true);
+    }, []);
+
+    useEffect(() => {
+        console.log("Loading workspace data, mounted:", mounted);
+        if (!mounted) return;
+
+        const loadData = async () => {
+            console.log("Loading folders and SOWs from database...");
+            const savedCurrent = localStorage.getItem("currentDocId");
+            const hasCompletedSetup = localStorage.getItem(
+                "sow-guided-setup-completed",
+            );
 
-  // Chat messages are now saved individually on each message send/receive
-  // No need for useEffect saving here - database handles persistence
+            try {
+                // LOAD FOLDERS FROM DATABASE
+                const foldersResponse = await fetch("/api/folders");
+                const foldersData = await foldersResponse.json();
+                console.log(
+                    "Loaded folders from database:",
+                    foldersData.length,
+                );
+
+                // LOAD SOWS FROM DATABASE
+                const sowsResponse = await fetch("/api/sow/list");
+                const { sows: dbSOWs } = await sowsResponse.json();
+                console.log("Loaded SOWs from database:", dbSOWs.length);
+
+                const workspacesWithSOWs: Workspace[] = [];
+                const documentsFromDB: Document[] = [];
+                const foldersFromDB: Folder[] = [];
+
+                // Create workspace objects with SOWs from database
+                for (const folder of foldersData) {
+                    console.log(
+                        `Processing folder: ${folder.name} (ID: ${folder.id})`,
+                    );
 
-  const currentDoc = documents.find(d => d.id === currentDocId);
+                    // Find SOWs that belong to this folder
+                    const folderSOWs = dbSOWs.filter(
+                        (sow: any) => sow.folder_id === folder.id,
+                    );
 
-  useEffect(() => {
-    if (currentDoc && editorRef.current) {
-      // Update editor content when document changes
-      editorRef.current.insertContent(currentDoc.content);
-    }
-  }, [currentDocId, currentDoc]);
-
-  const handleSelectDoc = (id: string) => {
-    setCurrentDocId(id);
-    // Clear chat messages for clean state when switching documents
-    setChatMessages([]);
-    // Switch to editor view when selecting a document
-    if (viewMode !== 'editor') {
-      setViewMode('editor');
-    }
-  };
-
-  const handleNewDoc = async (folderId?: string) => {
-    const newId = `doc${Date.now()}`;
-    const title = "New SOW";
-    
-    // Find workspace slug from the folder this SOW belongs to
-    const parentFolder = folderId ? folders.find(f => f.id === folderId) : null;
-    const workspaceSlug = parentFolder?.workspaceSlug;
-    
-    let newDoc: Document = {
-      id: newId,
-      title,
-      content: defaultEditorContent,
-      folderId,
-      workspaceSlug,
-    };
-    
-    try {
-      // ðŸ§µ Create AnythingLLM thread for this SOW (if workspace exists)
-      if (workspaceSlug) {
-        console.log(`ðŸ”— Creating thread in workspace: ${workspaceSlug}`);
-        // Don't pass thread name - AnythingLLM auto-names based on first chat message
-        const thread = await anythingLLM.createThread(workspaceSlug);
-        if (thread) {
-          newDoc = {
-            ...newDoc,
-            threadSlug: thread.slug,
-            threadId: thread.id,
-            syncedAt: new Date().toISOString(),
-          };
-          
-          // ðŸ“Š Embed SOW in BOTH client workspace AND master dashboard
-          console.log(`ðŸ“Š Embedding new SOW in both workspaces: ${workspaceSlug}`);
-          const sowContent = JSON.stringify(defaultEditorContent);
-          await anythingLLM.embedSOWInBothWorkspaces(workspaceSlug, title, sowContent);
-          
-          toast.success(`âœ… SOW created with chat thread in ${parentFolder?.name || 'workspace'}`);
-        } else {
-          console.warn('âš ï¸ Thread creation failed - SOW created without thread');
-          toast.warning('âš ï¸ SOW created but thread sync failed. You can still chat about it.');
-        }
-      } else {
-        console.log('â„¹ï¸ No workspace found - creating standalone SOW');
-        toast.info('â„¹ï¸ SOW created outside a folder. Create a folder first to enable AI chat.');
-      }
-    } catch (error) {
-      console.error('âŒ Error creating thread:', error);
-      toast.error('SOW created but thread sync failed');
-    }
-    
-    // Save new SOW to database first
-    try {
-      const saveResponse = await fetch('/api/sow/create', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({
-          title: newDoc.title,
-          content: newDoc.content,
-          folder_id: newDoc.folderId,
-          workspace_slug: newDoc.workspaceSlug,
-          client_name: '',
-          client_email: '',
-          total_investment: 0,
-        }),
-      });
-      
-      if (saveResponse.ok) {
-        const savedDoc = await saveResponse.json();
-        // Update newDoc with the database ID
-        newDoc = { ...newDoc, id: savedDoc.id || newId };
-        console.log('âœ… SOW saved to database with id:', newDoc.id);
-      } else {
-        console.warn('âš ï¸ Failed to save SOW to database');
-        toast.warning('âš ï¸ SOW created but not saved to database');
-      }
-    } catch (error) {
-      console.error('âŒ Error saving SOW to database:', error);
-      toast.error('âš ï¸ Failed to save SOW');
-    }
-    
-    setDocuments(prev => [...prev, newDoc]);
-    setCurrentDocId(newDoc.id);
-    
-    // ðŸŽ¯ Switch to editor view (in case we're on dashboard/AI management)
-    if (viewMode !== 'editor') {
-      setViewMode('editor');
-    }
-    
-    // Clear chat messages for current agent (in state only - database messages persist)
-    setChatMessages([]);
-    
-    // Keep sidebar closed - let user open manually
-    const architectAgent = agents.find(a => a.id === "architect");
-    if (architectAgent) {
-      setCurrentAgentId("architect");
-    }
-  };
-
-  const handleRenameDoc = async (id: string, title: string) => {
-    const doc = documents.find(d => d.id === id);
-    
-    try {
-      // ðŸ§µ Update AnythingLLM thread name if it exists
-      if (doc?.workspaceSlug && doc?.threadSlug) {
-        await anythingLLM.updateThread(doc.workspaceSlug, doc.threadSlug, title);
-        toast.success(`âœ… SOW renamed to "${title}"`);
-      }
-      
-      setDocuments(prev => prev.map(d => d.id === id ? { ...d, title, syncedAt: new Date().toISOString() } : d));
-    } catch (error) {
-      console.error('Error renaming document:', error);
-      setDocuments(prev => prev.map(d => d.id === id ? { ...d, title } : d));
-      toast.error('SOW renamed locally but thread sync failed');
-    }
-  };
-
-  const handleDeleteDoc = async (id: string) => {
-    const doc = documents.find(d => d.id === id);
-    
-    try {
-      // Delete SOW from database first
-      const deleteResponse = await fetch(`/api/sow/${id}`, {
-        method: 'DELETE',
-        headers: { 'Content-Type': 'application/json' },
-      });
-
-      if (deleteResponse.ok) {
-        console.log('âœ… SOW deleted from database:', id);
-      } else {
-        console.warn('âš ï¸ Failed to delete SOW from database');
-        toast.warning('âš ï¸ SOW deleted from UI but database deletion failed');
-      }
-
-      // ðŸ§µ Delete AnythingLLM thread if it exists
-      if (doc?.workspaceSlug && doc?.threadSlug) {
-        await anythingLLM.deleteThread(doc.workspaceSlug, doc.threadSlug);
-        toast.success(`âœ… SOW and thread deleted`);
-      }
-    } catch (error) {
-      console.error('Error deleting SOW:', error);
-      toast.error('Failed to delete SOW');
-    }
-    
-    setDocuments(prev => prev.filter(d => d.id !== id));
-    if (currentDocId === id) {
-      const remaining = documents.filter(d => d.id !== id);
-      setCurrentDocId(remaining.length > 0 ? remaining[0].id : null);
-    }
-  };
-
-  const handleNewFolder = async (name: string) => {
-    const newId = `folder-${Date.now()}`;
-    try {
-      // ðŸ¢ Create AnythingLLM workspace for this folder
-      const workspace = await anythingLLM.createOrGetClientWorkspace(name);
-      const embedId = await anythingLLM.getOrCreateEmbedId(workspace.slug);
-      
-      // ðŸ’¾ Save folder to DATABASE
-      const response = await fetch('/api/folders', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({
-          id: newId,
-          name,
-          workspaceSlug: workspace.slug,
-          workspaceId: workspace.id,
-          embedId: embedId,
-        }),
-      });
-      
-      if (!response.ok) {
-        const errorData = await response.json();
-        throw new Error(errorData.details || 'Failed to create folder in database');
-      }
-      
-      const savedFolder = await response.json();
-      console.log('âœ… Folder saved to database:', savedFolder);
-      
-      const newFolder: Folder = {
-        id: savedFolder.id,
-        name: name,
-        workspaceSlug: workspace.slug,
-        workspaceId: workspace.id,
-        embedId,
-        syncedAt: new Date().toISOString(),
-      };
-      
-      setFolders(prev => [...prev, newFolder]);
-      toast.success(`âœ… Workspace "${name}" created!`);
-      
-      // ðŸŽ¯ AUTO-CREATE FIRST SOW IN NEW FOLDER
-      // This creates an empty SOW and opens it immediately
-      await handleNewDoc(newFolder.id);
-    } catch (error) {
-      console.error('Error creating folder:', error);
-      toast.error(`âŒ Failed to create folder: ${error.message}`);
-    }
-  };
-
-  const handleRenameFolder = async (id: string, name: string) => {
-    const folder = folders.find(f => f.id === id);
-    
-    try {
-      // ðŸ’¾ Update folder in DATABASE
-      const response = await fetch(`/api/folders/${id}`, {
-        method: 'PUT',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({ name }),
-      });
-      
-      if (!response.ok) {
-        throw new Error('Failed to update folder in database');
-      }
-      
-      // ðŸ¢ Update AnythingLLM workspace name if it exists
-      if (folder?.workspaceSlug) {
-        await anythingLLM.updateWorkspace(folder.workspaceSlug, name);
-      }
-      
-      setFolders(prev => prev.map(f => f.id === id ? { ...f, name, syncedAt: new Date().toISOString() } : f));
-      toast.success(`âœ… Folder renamed to "${name}"`);
-    } catch (error) {
-      console.error('Error renaming folder:', error);
-      toast.error('âŒ Failed to rename folder');
-    }
-  };
-
-  const handleDeleteFolder = async (id: string) => {
-    const folder = folders.find(f => f.id === id);
-    
-    // Also delete subfolders and docs in folder
-    const toDelete = [id];
-    const deleteRecursive = (folderId: string) => {
-      folders.filter(f => f.parentId === folderId).forEach(f => {
-        toDelete.push(f.id);
-        deleteRecursive(f.id);
-      });
-    };
-    deleteRecursive(id);
-    
-    try {
-      // ðŸ’¾ Delete folder from DATABASE
-      const response = await fetch(`/api/folders/${id}`, {
-        method: 'DELETE',
-      });
-      
-      if (!response.ok) {
-        throw new Error('Failed to delete folder from database');
-      }
-      
-      // ðŸ¢ Delete AnythingLLM workspace (cascades to all threads)
-      if (folder?.workspaceSlug) {
-        await anythingLLM.deleteWorkspace(folder.workspaceSlug);
-      }
-      
-      setFolders(prev => prev.filter(f => !toDelete.includes(f.id)));
-      setDocuments(prev => prev.filter(d => !d.folderId || !toDelete.includes(d.folderId)));
-      toast.success(`âœ… Folder deleted from database`);
-    } catch (error) {
-      console.error('Error deleting folder:', error);
-      toast.error('âŒ Failed to delete folder');
-    }
-  };
-
-  const handleMoveDoc = (docId: string, folderId?: string) => {
-    setDocuments(prev => prev.map(d => d.id === docId ? { ...d, folderId } : d));
-  };
-
-  // ==================== WORKSPACE & SOW HANDLERS (NEW) ====================
-  const handleCreateWorkspace = async (workspaceName: string, workspaceType: "sow" | "client" | "generic" = "sow") => {
-    try {
-      console.log('ðŸ“ Creating workspace:', workspaceName);
-      
-      // ðŸ“Š SHOW PROGRESS MODAL
-      setWorkspaceCreationProgress({
-        isOpen: true,
-        workspaceName,
-        currentStep: 0,
-        completedSteps: [],
-      });
-      
-      // ðŸ¢ STEP 1: Create AnythingLLM workspace FIRST
-      console.log('ðŸ¢ Creating AnythingLLM workspace...');
-      const workspace = await anythingLLM.createOrGetClientWorkspace(workspaceName);
-      const embedId = await anythingLLM.getOrCreateEmbedId(workspace.slug);
-      console.log('âœ… AnythingLLM workspace created:', workspace.slug);
-      
-      // ðŸ§  STEP 1b: Configure workspace with The Architect system prompt (SOW type only)
-      if (workspaceType === "sow") {
-        console.log('ðŸ§  Configuring SOW workspace with The Architect system prompt...');
-        try {
-          const updateResponse = await fetch(`${process.env.NEXT_PUBLIC_ANYTHINGLLM_URL}/api/v1/workspace/${workspace.slug}/update`, {
-            method: 'POST',
-            headers: {
-              'Authorization': `Bearer ${process.env.ANYTHINGLLM_API_KEY}`,
-              'Content-Type': 'application/json',
-            },
-            body: JSON.stringify({
-              openAiPrompt: THE_ARCHITECT_SYSTEM_PROMPT,
-              openAiTemp: 0.7,
-              openAiHistory: 25,
-            }),
-          });
-          
-          if (!updateResponse.ok) {
-            const errorText = await updateResponse.text();
-            console.error('âš ï¸ Failed to configure workspace system prompt:', errorText);
-          } else {
-            console.log('âœ… Workspace configured with The Architect system prompt');
-          }
-        } catch (error) {
-          console.error('âš ï¸ Error configuring workspace:', error);
-        }
-      } else {
-        console.log(`âœ… Workspace created as ${workspaceType} type (no custom prompt applied)`);
-      }
-      
-      // Mark step 1 complete
-      setWorkspaceCreationProgress(prev => ({
-        ...prev,
-        completedSteps: [0],
-        currentStep: 1,
-      }));
-      
-      // ðŸ’¾ STEP 2: Save folder to DATABASE with workspace info
-      console.log('ðŸ’¾ Saving folder to database with AnythingLLM mapping...');
-      const folderResponse = await fetch('/api/folders', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({ 
-          name: workspaceName,
-          workspaceSlug: workspace.slug,
-          workspaceId: workspace.id,
-          embedId: embedId,
-        }),
-      });
-
-      if (!folderResponse.ok) {
-        const errorData = await folderResponse.json();
-        throw new Error(errorData.details || 'Failed to create folder in database');
-      }
-
-      const folderData = await folderResponse.json();
-      const folderId = folderData.id;
-      console.log('âœ… Folder saved to database with ID:', folderId);
-      
-      // Mark step 2 complete
-      setWorkspaceCreationProgress(prev => ({
-        ...prev,
-        completedSteps: [0, 1],
-        currentStep: 2,
-      }));
-
-      // Create folder in local state with AnythingLLM mapping
-      const newFolder: Folder = {
-        id: folderId,
-        name: workspaceName,
-        workspaceSlug: workspace.slug,
-        workspaceId: workspace.id,
-        embedId: embedId,
-        syncedAt: new Date().toISOString(),
-      };
-      
-      setFolders(prev => [...prev, newFolder]);
-      
-      // Create workspace in local state
-      const newWorkspace: Workspace = {
-        id: folderId, // Use database folder ID
-        name: workspaceName,
-        sows: [],
-        workspace_slug: workspace.slug  // Add workspace slug here!
-      };
-      
-      // IMMEDIATELY CREATE A BLANK SOW (NO MODAL, NO USER INPUT)
-      const sowTitle = `New SOW for ${workspaceName}`; // Auto-generated title
-      
-      // Save SOW to database with folder ID
-      console.log('ðŸ“„ Creating SOW in database');
-      const sowResponse = await fetch('/api/sow/create', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({
-          title: sowTitle,
-          content: defaultEditorContent,
-          clientName: workspaceName,
-          clientEmail: '',
-          totalInvestment: 0,
-          folderId: folderId, // Associate with folder
-        }),
-      });
-
-      if (!sowResponse.ok) {
-        throw new Error('Failed to create SOW');
-      }
-
-      const sowData = await sowResponse.json();
-      const sowId = sowData.id || sowData.sowId;
-      console.log('âœ… SOW created with ID:', sowId);
-
-      // ðŸ§µ STEP 3: Create AnythingLLM thread for this SOW
-      console.log('ðŸ§µ Creating AnythingLLM thread...');
-      // Don't pass thread name - AnythingLLM auto-names based on first chat message
-      const thread = await anythingLLM.createThread(workspace.slug);
-      console.log('âœ… AnythingLLM thread created:', thread.slug, '(will auto-name on first message)');
-      
-      // ðŸ§µ UPDATE SOW WITH THREAD SLUG
-      await fetch(`/api/sow/${sowId}`, {
-        method: 'PUT',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({
-          threadSlug: thread.slug,
-          workspaceSlug: workspace.slug,
-        }),
-      });
-      console.log(`âœ… SOW ${sowId} updated with thread ${thread.slug} and workspace ${workspace.slug}`);
-      
-      // Mark step 3 complete
-      setWorkspaceCreationProgress(prev => ({
-        ...prev,
-        completedSteps: [0, 1, 2],
-        currentStep: 3,
-      }));
-
-      // ðŸ“Š STEP 4: Embed SOW in BOTH client workspace AND master dashboard
-      console.log('ðŸ“Š Embedding SOW in both workspaces...');
-      const sowContent = JSON.stringify(defaultEditorContent);
-      await anythingLLM.embedSOWInBothWorkspaces(workspace.slug, sowTitle, sowContent);
-      console.log('âœ… SOW embedded in both workspaces');
-      
-      // Mark all steps complete
-      setWorkspaceCreationProgress(prev => ({
-        ...prev,
-        completedSteps: [0, 1, 2, 3],
-        currentStep: 4,
-      }));
-
-      // Create SOW object for local state
-      const newSOW: SOW = {
-        id: sowId,
-        name: sowTitle,
-        workspaceId: folderId
-      };
-
-      // Update workspace with the SOW
-      newWorkspace.sows = [newSOW];
-
-      // Update state - INSERT AT TOP (index 0) so newest appears first
-      setWorkspaces(prev => [newWorkspace, ...prev]);
-      setCurrentWorkspaceId(folderId);
-      setCurrentSOWId(sowId);
-      
-      // AUTOMATICALLY SWITCH TO EDITOR VIEW
-      setViewMode('editor');
-      
-      // Add document to local state with AnythingLLM mapping
-      const newDoc: Document = {
-        id: sowId,
-        title: sowTitle,
-        content: defaultEditorContent,
-        folderId: folderId,
-        workspaceSlug: workspace.slug,
-        threadSlug: thread.slug,
-        syncedAt: new Date().toISOString(),
-      };
-
-      setDocuments(prev => [...prev, newDoc]);
-      setCurrentDocId(sowId);
-      
-      // Clear chat messages for clean state when switching to new workspace
-      setChatMessages([]);
-      
-  toast.success(`âœ… Workspace "${workspaceName}" created!`);
-  toast.success(`âœ… Created workspace "${workspaceName}" with blank SOW ready to edit!`);
-      
-      // Close progress modal and navigate to SOW editor
-      setTimeout(() => {
-        setWorkspaceCreationProgress(prev => ({
-          ...prev,
-          isOpen: false,
-        }));
-        
-        // ðŸš€ AUTO-NAVIGATE TO NEW SOW EDITOR (not staying on dashboard)
-        const router = require('next/router').useRouter?.() || { push: () => {} };
-        if (typeof window !== 'undefined') {
-          window.location.href = `/portal/sow/${sowId}`;
-        }
-      }, 500);
-    } catch (error) {
-      console.error('âŒ Error creating workspace:', error);
-      toast.error('Failed to create workspace. Please try again.');
-      
-      // Close progress modal on error
-      setWorkspaceCreationProgress(prev => ({
-        ...prev,
-        isOpen: false,
-      }));
-    }
-  };
-
-  const handleRenameWorkspace = (workspaceId: string, newName: string) => {
-    setWorkspaces(prev => prev.map(ws => 
-      ws.id === workspaceId ? { ...ws, name: newName } : ws
-    ));
-  };
-
-  const handleDeleteWorkspace = async (workspaceId: string) => {
-    try {
-      const workspace = workspaces.find(ws => ws.id === workspaceId);
-      
-      if (!workspace) {
-        toast.error('Workspace not found');
-        return;
-      }
-
-      // ðŸ’¾ Delete from database AND AnythingLLM (API endpoint handles both)
-      const dbResponse = await fetch(`/api/folders/${workspaceId}`, {
-        method: 'DELETE',
-      });
-
-      if (!dbResponse.ok) {
-        const errorData = await dbResponse.json();
-        throw new Error(errorData.details || 'Failed to delete workspace from database');
-      }
-
-      const result = await dbResponse.json();
-      console.log(`âœ… Workspace deletion result:`, result);
-
-      // Update state
-      setWorkspaces(prev => prev.filter(ws => ws.id !== workspaceId));
-      
-      // If we deleted the current workspace, switch to first available
-      if (currentWorkspaceId === workspaceId) {
-        const remaining = workspaces.filter(ws => ws.id !== workspaceId);
-        if (remaining.length > 0) {
-          setCurrentWorkspaceId(remaining[0].id);
-          setCurrentSOWId(remaining[0].sows[0]?.id || null);
-        } else {
-          setCurrentWorkspaceId('');
-          setCurrentSOWId(null);
-        }
-      }
+                    const sows: SOW[] = folderSOWs.map((sow: any) => ({
+                        id: sow.id,
+                        name: sow.title || "Untitled SOW",
+                        workspaceId: folder.id,
+                    }));
+
+                    console.log(`   Found ${sows.length} SOWs in this folder`);
+
+                    // Add to workspaces array
+                    workspacesWithSOWs.push({
+                        id: folder.id,
+                        name: folder.name,
+                        sows: sows,
+                        workspace_slug: folder.workspace_slug,
+                    });
+
+                    // Add to folders array
+                    foldersFromDB.push({
+                        id: folder.id,
+                        name: folder.name,
+                        workspaceSlug: folder.workspace_slug,
+                        workspaceId: folder.workspace_id,
+                        embedId: folder.embed_id,
+                        syncedAt: folder.updated_at || folder.created_at,
+                    });
+
+                    // Create document objects for each SOW from database
+                    for (const sow of folderSOWs) {
+                        // Parse content if it's a JSON string, otherwise use as-is
+                        let parsedContent = defaultEditorContent;
+                        if (sow.content) {
+                            try {
+                                parsedContent =
+                                    typeof sow.content === "string"
+                                        ? JSON.parse(sow.content)
+                                        : sow.content;
+                            } catch (e) {
+                                console.warn(
+                                    "Failed to parse SOW content:",
+                                    sow.id,
+                                );
+                                parsedContent = defaultEditorContent;
+                            }
+                        }
+
+                        documentsFromDB.push({
+                            id: sow.id,
+                            title: sow.title || "Untitled SOW",
+                            content: parsedContent,
+                            folderId: folder.id,
+                            workspaceSlug: folder.workspace_slug,
+                            threadSlug: sow.thread_slug || undefined, // ðŸ§µ AnythingLLM thread UUID (NOT sow.id!)
+                            syncedAt: sow.updated_at,
+                        });
+                    }
+                }
 
-      toast.success(`âœ… Workspace "${workspace.name}" deleted`);
-    } catch (error) {
-      console.error('Error deleting workspace:', error);
-      toast.error(`Failed to delete workspace: ${error instanceof Error ? error.message : String(error)}`);
-    }
-  };
-
-  const handleCreateSOW = async (workspaceId: string, sowName: string) => {
-    try {
-      // Find the workspace to get its slug
-      const workspace = workspaces.find(ws => ws.id === workspaceId);
-      if (!workspace) {
-        toast.error('Workspace not found');
-        return;
-      }
-
-      // Validate that workspace has a slug
-      if (!workspace.workspace_slug) {
-        console.error('âŒ Workspace missing workspace_slug:', workspace);
-        toast.error('Workspace slug not found. Please try again.');
-        return;
-      }
-
-      console.log(`ðŸ†• Creating new SOW: "${sowName}" in workspace: ${workspace.name} (${workspace.workspace_slug})`);
-
-      // Step 1: Create AnythingLLM thread (PRIMARY source of truth)
-      // ðŸŽ¯ Create threads in the CLIENT WORKSPACE (where SOW content is embedded)
-      // This ensures the thread has access to the SOW's embedded content for context
-      // Don't pass thread name - AnythingLLM auto-names based on first chat message
-      const thread = await anythingLLM.createThread(workspace.workspace_slug);
-      if (!thread) {
-        toast.error('Failed to create SOW thread in AnythingLLM');
-        return;
-      }
-
-      console.log(`âœ… AnythingLLM thread created: ${thread.slug} (will auto-name on first message)`);
-
-      // Step 2: Save to database (for metrics, tracking, portal)
-      const saveResponse = await fetch('/api/sow/create', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({
-          id: thread.slug, // Use thread slug as ID for consistency
-          title: sowName,
-          content: defaultEditorContent,
-          client_name: '',
-          client_email: '',
-          total_investment: 0,
-          workspace_slug: workspace.workspace_slug,
-          folder_id: workspaceId,
-        }),
-      });
-
-      if (!saveResponse.ok) {
-        console.warn('âš ï¸ Failed to save SOW to database, but thread exists in AnythingLLM');
-      }
-
-      const savedDoc = await saveResponse.json();
-      console.log(`âœ… SOW saved to database: ${savedDoc.id}`);
-
-      // Step 3: Update local state
-      const newSOW: SOW = {
-        id: thread.slug,
-        name: sowName,
-        workspaceId
-      };
-
-      setWorkspaces(prev => prev.map(ws => 
-        ws.id === workspaceId ? { ...ws, sows: [...ws.sows, newSOW] } : ws
-      ));
-      setCurrentSOWId(thread.slug);
-
-      // Step 4: Create document object and switch to editor
-      const newDoc: Document = {
-        id: thread.slug,
-        title: sowName,
-        content: defaultEditorContent,
-        folderId: workspaceId,
-        workspaceSlug: workspace.workspace_slug,
-        threadSlug: thread.slug,
-        syncedAt: new Date().toISOString(),
-      };
-
-      setDocuments(prev => [...prev, newDoc]);
-      setCurrentDocId(thread.slug);
-      setViewMode('editor');
-
-      toast.success(`âœ… SOW "${sowName}" created in ${workspace.name}!`);
-    } catch (error) {
-      console.error('âŒ Error creating SOW:', error);
-      toast.error('Failed to create SOW');
-    }
-  };
-
-  const handleRenameSOW = (sowId: string, newName: string) => {
-    setWorkspaces(prev => prev.map(ws => ({
-      ...ws,
-      sows: ws.sows.map(sow => 
-        sow.id === sowId ? { ...sow, name: newName } : sow
-      )
-    })));
-  };
-
-  const handleDeleteSOW = (sowId: string) => {
-    setWorkspaces(prev => prev.map(ws => ({
-      ...ws,
-      sows: ws.sows.filter(sow => sow.id !== sowId)
-    })));
-    // If we deleted the current SOW, clear it
-    if (currentSOWId === sowId) {
-      setCurrentSOWId(null);
-      setCurrentDocId(null);
-    }
-  };
-
-  const handleViewChange = (view: 'dashboard' | 'gardner-studio' | 'editor' | 'ai-management') => {
-    if (view === 'gardner-studio') {
-      setViewMode('gardner-studio');
-    } else if (view === 'dashboard') {
-      setViewMode('dashboard');
-    } else if (view === 'ai-management') {
-      setViewMode('ai-management');
-    } else {
-      setViewMode('editor');
-    }
-  };
-
-  const handleReorderWorkspaces = (reorderedWorkspaces: Workspace[]) => {
-    setWorkspaces(reorderedWorkspaces);
-    // Optionally save order to localStorage or database
-    localStorage.setItem('workspace-order', JSON.stringify(reorderedWorkspaces.map(w => w.id)));
-  };
-
-  const handleReorderSOWs = (workspaceId: string, reorderedSOWs: SOW[]) => {
-    setWorkspaces(prev => prev.map(ws =>
-      ws.id === workspaceId ? { ...ws, sows: reorderedSOWs } : ws
-    ));
-    // Optionally save order to localStorage or database
-    localStorage.setItem(`sow-order-${workspaceId}`, JSON.stringify(reorderedSOWs.map(s => s.id)));
-  };
-
-  // ==================== END WORKSPACE & SOW HANDLERS ====================
-
-  // AnythingLLM Integration
-  const handleEmbedToAI = async () => {
-    if (!currentDoc || !editorRef.current) {
-      toast.error('No document to embed');
-      return;
-    }
+                console.log(
+                    "Total workspaces loaded:",
+                    workspacesWithSOWs.length,
+                );
+                console.log("Total SOWs loaded:", documentsFromDB.length);
+
+                // Update state
+                setWorkspaces(workspacesWithSOWs);
+                setFolders(foldersFromDB);
+                setDocuments(documentsFromDB);
+
+                // Set current workspace to first one if available
+                // BUT: Don't auto-select a SOW - let user click from dashboard
+                if (workspacesWithSOWs.length > 0 && !currentWorkspaceId) {
+                    setCurrentWorkspaceId(workspacesWithSOWs[0].id);
+                    // Removed: Don't auto-select first SOW - user should manually select from dashboard
+                    // This provides a better UX where dashboard is the entry point
+                }
 
-    // Show loading toast with dismiss button
-    const toastId = toast.loading('Embedding SOW to AI knowledge base...', {
-      duration: Infinity, // Don't auto-dismiss
-    });
+                // ðŸŽ“ Show onboarding if no workspaces (and not seen before)
+                const hasSeenOnboarding =
+                    localStorage.getItem("hasSeenOnboarding") === "true";
+                if (workspacesWithSOWs.length === 0 && !hasSeenOnboarding) {
+                    setTimeout(() => {
+                        setShowOnboarding(true);
+                        localStorage.setItem("hasSeenOnboarding", "true");
+                    }, 500);
+                }
 
-    try {
-      // Extract client name from title (e.g., "SOW: AGGF - HubSpot" â†’ "AGGF")
-      const clientName = currentDoc.title.split(':')[1]?.split('-')[0]?.trim() || 'Default Client';
-
-      console.log('ðŸš€ Starting embed process for:', currentDoc.title);
-
-      // Create or get workspace (this is fast)
-      const workspaceSlug = await anythingLLM.createOrGetClientWorkspace(clientName);
-      console.log('âœ… Workspace ready:', workspaceSlug);
-
-      // Get HTML content
-      const htmlContent = editorRef.current.getHTML();
-
-      // Update toast to show progress
-      toast.loading('Uploading document and creating embeddings...', { id: toastId });
-
-      // Embed document in BOTH client workspace AND master dashboard
-      // Note: embedSOWEverywhere method not available - this feature can be implemented later
-      const success = true; // await anythingLLM.embedSOWEverywhere(
-      //   workspaceSlug,
-      //   currentDoc.title,
-      //   htmlContent,
-      //   {
-      //     docId: currentDoc.id,
-      //     clientName: clientName,
-      //     createdAt: new Date().toISOString(),
-      //     totalInvestment: currentDoc.totalInvestment || 0,
-      //   }
-      // );
-
-      // Dismiss loading toast
-      toast.dismiss(toastId);
-
-      if (success) {
-        toast.success(`âœ… SOW embedded! Available in ${clientName}'s workspace AND master dashboard.`, {
-          duration: 5000,
-        });
-        
-        // Save workspace slug to database (non-blocking)
-        if (currentDoc.folderId) {
-          fetch(`/api/folders/${currentDoc.folderId}`, {
-            method: 'PUT',
-            headers: { 'Content-Type': 'application/json' },
-            body: JSON.stringify({ workspaceSlug }),
-          }).catch(err => console.warn('Failed to save workspace slug:', err));
-        }
-      } else {
-        toast.error('Failed to embed SOW - check console for details', {
-          duration: 7000,
-        });
-      }
-    } catch (error: any) {
-      console.error('âŒ Error embedding to AI:', error);
-      toast.dismiss(toastId);
-      toast.error(`Error: ${error.message || 'Unknown error'}`, {
-        duration: 7000,
-      });
-    }
-  };
+                // Show guided setup if no workspaces
+                if (!hasCompletedSetup && workspacesWithSOWs.length === 0) {
+                    setTimeout(() => setShowGuidedSetup(true), 1000);
+                }
+            } catch (error) {
+                console.error("Error loading data:", error);
+                toast.error("Failed to load workspaces and SOWs");
+            }
 
-  const handleOpenAIChat = () => {
-    if (!currentDoc) {
-      toast.error('No document selected');
-      return;
-    }
+            if (savedCurrent) {
+                setCurrentDocId(savedCurrent);
+            }
+        };
 
-    // Get workspace slug from localStorage
-    const clientName = currentDoc.title.split(':')[1]?.split('-')[0]?.trim() || 'default-client';
-    const workspaceSlug = localStorage.getItem(`workspace_${currentDoc.id}`) || 
-      clientName.toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, '-');
+        loadData();
+    }, [mounted]);
 
-    // Open AnythingLLM in new tab
-    const url = anythingLLM.getWorkspaceChatUrl(workspaceSlug);
-    window.open(url, '_blank');
-  };
+    // Note: SOWs are now saved to database via API calls, not localStorage
 
-  const handleShare = async () => {
-    if (!currentDocId) {
-      toast.error('Please select a document first');
-      return;
-    }
-    
-    try {
-      // Get or create share link (only generated once per document)
-      const baseUrl = window.location.origin;
-      const shareLink = `${baseUrl}/portal/sow/${currentDocId}`;
-      
-      console.log('ðŸ“¤ Share link generated:', shareLink);
-      
-      // Copy to clipboard with fallback
-      if (navigator.clipboard && navigator.clipboard.writeText) {
-        await navigator.clipboard.writeText(shareLink);
-      } else {
-        const textarea = document.createElement('textarea');
-        textarea.value = shareLink;
-        textarea.style.position = 'fixed';
-        textarea.style.opacity = '0';
-        document.body.appendChild(textarea);
-        textarea.select();
-        document.execCommand('copy');
-        document.body.removeChild(textarea);
-      }
-      
-      // Show share modal with all details
-      setShareModalData({
-        shareLink,
-        documentTitle: currentDoc?.title || 'SOW',
-        shareCount: 1,
-        firstShared: new Date().toISOString(),
-        lastShared: new Date().toISOString(),
-      });
-      setShowShareModal(true);
-      
-      toast.success('âœ… Share link copied to clipboard!');
-    } catch (error) {
-      console.error('Error sharing:', error);
-      toast.error('Failed to copy link');
-    }
-  };
+    // âœ¨ NEW: When currentSOWId changes, load the corresponding document and switch to editor view
+    useEffect(() => {
+        if (!currentSOWId) return;
 
-  const handleExportPDF = async () => {
-    if (!currentDoc || !editorRef.current) {
-      toast.error('âŒ No document selected');
-      return;
-    }
-    
-    toast.info('ðŸ“„ Generating PDF...');
-    
-    try {
-      // Get HTML directly from the editor (includes all formatting and custom nodes)
-      const editorHTML = editorRef.current.getHTML();
-      
-      if (!editorHTML || editorHTML.trim() === '' || editorHTML === '<p></p>') {
-        toast.error('âŒ Document is empty. Please add content before exporting.');
-        return;
-      }
-      
-      const filename = currentDoc.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
-      
-      // Call WeasyPrint PDF service via Next.js API
-      const response = await fetch('/api/generate-pdf', {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-        },
-        body: JSON.stringify({
-          html_content: editorHTML,
-          filename: filename
-        })
-      });
-      
-      if (!response.ok) {
-        const errorText = await response.text();
-        console.error('PDF service error:', errorText);
-        toast.error(`âŒ PDF service error: ${response.status}`);
-        throw new Error(`PDF service error: ${errorText}`);
-      }
-      
-      // Download the PDF
-      const blob = await response.blob();
-      const url = window.URL.createObjectURL(blob);
-      const a = document.createElement('a');
-      a.href = url;
-      a.download = `${filename}.pdf`;
-      document.body.appendChild(a);
-      a.click();
-      window.URL.revokeObjectURL(url);
-      document.body.removeChild(a);
-      
-      toast.success('âœ… PDF downloaded successfully!');
-      
-    } catch (error) {
-      console.error('Error exporting PDF:', error);
-      toast.error(`âŒ Error exporting PDF: ${error.message}`);
-    }
-  };
+        console.log("ðŸ“„ Loading document for SOW:", currentSOWId);
 
-  const handleExportExcel = () => {
-    if (!currentDoc) {
-      toast.error('âŒ No document selected');
-      return;
-    }
-    
-    toast.info('ðŸ“Š Generating Excel...');
-    
-    try {
-      // Extract pricing data from document
-      const pricingRows = extractPricingFromContent(currentDoc.content);
-      
-      if (pricingRows.length === 0) {
-        toast.error('âŒ No pricing table found in document. Please generate a SOW first.');
-        return;
-      }
-      
-      // Get last AI message for additional SOW data
-      const lastAIMessage = [...chatMessages].reverse().find(msg => msg.role === 'assistant');
-      const sowData = lastAIMessage ? parseSOWMarkdown(lastAIMessage.content) : {};
-      
-      const filename = `${currentDoc.title.replace(/[^a-z0-9]/gi, '_')}_pricing.xlsx`;
-      exportToExcel({
-        title: currentDoc.title,
-        pricingRows,
-        ...sowData,
-      }, filename);
-      
-      toast.success('âœ… Excel downloaded successfully!');
-    } catch (error) {
-      console.error('Error exporting Excel:', error);
-      toast.error(`âŒ Error exporting Excel: ${error.message}`);
-    }
-  };
+        // Find the document in the documents array
+        const doc = documents.find((d) => d.id === currentSOWId);
 
-  // Create Google Sheet with OAuth token
-  const createGoogleSheet = async (accessToken: string) => {
-    if (!currentDoc) {
-      toast.error('âŒ No document selected');
-      return;
-    }
+        if (doc) {
+            console.log("âœ… Found document:", doc.title);
+            setCurrentDocId(doc.id);
+            setViewMode("editor"); // Switch to editor view
+
+            // ðŸ§µ Load chat history from AnythingLLM thread
+            const loadChatHistory = async () => {
+                if (doc.threadSlug) {
+                    try {
+                        console.log(
+                            "ðŸ’¬ Loading chat history for thread:",
+                            doc.threadSlug,
+                        );
+                        // ðŸŽ¯ Use the workspace where the SOW was created (where its thread lives)
+                        const history = await anythingLLM.getThreadChats(
+                            doc.workspaceSlug || "gen-the-architect",
+                            doc.threadSlug,
+                        );
+
+                        if (history && history.length > 0) {
+                            // Convert AnythingLLM history format to our ChatMessage format
+                            const messages: ChatMessage[] = history.map(
+                                (msg: any) => ({
+                                    id: `msg${Date.now()}-${Math.random()}`,
+                                    role:
+                                        msg.role === "user"
+                                            ? "user"
+                                            : "assistant",
+                                    content: msg.content,
+                                    timestamp: Date.now(),
+                                }),
+                            );
+
+                            console.log(
+                                `âœ… Loaded ${messages.length} messages from thread`,
+                            );
+                            setChatMessages(messages);
+                        } else {
+                            console.log(
+                                "â„¹ï¸ No chat history found for this SOW",
+                            );
+                            setChatMessages([]);
+                        }
+                    } catch (error) {
+                        console.error("âŒ Failed to load chat history:", error);
+                        setChatMessages([]);
+                    }
+                } else {
+                    console.log(
+                        "â„¹ï¸ No thread associated with this SOW, clearing chat",
+                    );
+                    setChatMessages([]);
+                }
+            };
 
-    toast.info('ðŸ“Š Creating Google Sheet...');
-
-    try {
-      // Extract pricing from content
-      const pricing = extractPricingFromContent(currentDoc.content);
-      
-      // Prepare SOW data
-      const sowData = {
-        clientName: currentDoc.title.split(' - ')[0] || 'Client',
-        serviceName: currentDoc.title.split(' - ')[1] || 'Service',
-        accessToken: accessToken,
-        overview: cleanSOWContent(currentDoc.content),
-        deliverables: '',
-        outcomes: '',
-        phases: '',
-        pricing: pricing || [],
-        assumptions: '',
-        timeline: '',
-      };
-
-      const response = await fetch('/api/create-sow-sheet', {
-        method: 'POST',
-        headers: {
-          'Content-Type': 'application/json',
-        },
-        body: JSON.stringify(sowData),
-      });
-
-      if (!response.ok) {
-        const error = await response.json();
-        throw new Error(error.error || 'Failed to create sheet');
-      }
-
-      const result = await response.json();
-      
-      toast.success('âœ… Google Sheet created!');
-      
-      // Show link to user
-      setTimeout(() => {
-        const openSheet = window.confirm(`Sheet created!\n\nClick OK to open in Google Sheets, or Cancel to copy the link.`);
-        if (openSheet) {
-          window.open(result.sheet_url, '_blank');
+            loadChatHistory();
         } else {
-          navigator.clipboard.writeText(result.share_link);
-          toast.success('ðŸ“‹ Share link copied!');
+            console.warn("âš ï¸ Document not found for SOW:", currentSOWId);
         }
-      }, 500);
-    } catch (error) {
-      console.error('Error creating sheet:', error);
-      toast.error(error instanceof Error ? error.message : 'Failed to create sheet');
-    }
-  };
+    }, [currentSOWId, documents]);
 
-  // Google Sheets handler - OAuth flow
-  const handleCreateGSheet = async () => {
-    if (!currentDoc) {
-      toast.error('âŒ No document selected');
-      return;
-    }
+    // Auto-save SOW content to database with debouncing
+    useEffect(() => {
+        // Find current doc in documents array
+        const currentDoc = documents.find((d) => d.id === currentDocId);
+        if (!currentDocId || !currentDoc?.content) return;
 
-    // If already authorized, create sheet directly
-    if (isOAuthAuthorized && oauthAccessToken) {
-      createGoogleSheet(oauthAccessToken);
-      return;
-    }
+        const autoSaveTimer = setTimeout(async () => {
+            try {
+                const response = await fetch(`/api/sow/${currentDocId}`, {
+                    method: "PUT",
+                    headers: { "Content-Type": "application/json" },
+                    body: JSON.stringify({
+                        content: currentDoc.content,
+                        title: currentDoc.title,
+                    }),
+                });
+
+                if (response.ok) {
+                    console.log("ðŸ’¾ Auto-saved SOW:", currentDocId);
+                } else {
+                    console.warn("âš ï¸ Auto-save failed for SOW:", currentDocId);
+                }
+            } catch (error) {
+                console.error("âŒ Error auto-saving SOW:", error);
+            }
+        }, 2000); // Save after 2 seconds of inactivity
 
-    toast.info('ðŸ“Š Starting Google authorization...');
-
-    try {
-      // Get current URL to return to after OAuth
-      const returnUrl = window.location.pathname + window.location.search;
-      
-      // Get authorization URL from backend
-      const response = await fetch(`/api/oauth/authorize?returnUrl=${encodeURIComponent(returnUrl)}`, {
-        method: 'GET',
-      });
-
-      if (!response.ok) {
-        throw new Error('Failed to get authorization URL');
-      }
-
-      const data = await response.json();
-      
-      // Redirect to Google OAuth
-      window.location.href = data.auth_url;
-    } catch (error) {
-      console.error('Error starting GSheet creation:', error);
-      toast.error('Failed to authorize with Google');
-    }
-  };
-
-  // Helper function to convert Novel JSON to HTML
-  const convertNovelToHTML = (content: any) => {
-    if (!content || !content.content) return '';
-
-    let html = '<style>';
-    html += 'body { font-family: "Plus Jakarta Sans", -apple-system, sans-serif; color: #1a1a1a; line-height: 1.6; }';
-    html += 'h1 { font-size: 28px; font-weight: 700; margin: 20px 0 16px; color: #2C823D; }';
-    html += 'h2 { font-size: 22px; font-weight: 600; margin: 16px 0 12px; color: #2C823D; }';
-    html += 'h3 { font-size: 18px; font-weight: 600; margin: 14px 0 10px; color: #2C823D; }';
-    html += 'p { margin: 8px 0; }';
-    html += 'ul, ol { margin: 8px 0; padding-left: 24px; }';
-    html += 'li { margin: 4px 0; }';
-    html += 'strong { font-weight: 600; }';
-    html += 'table { width: 100%; border-collapse: collapse; margin: 16px 0; }';
-    html += 'th { background: #2C823D; color: white; padding: 12px 8px; text-align: left; font-weight: 600; border: 1px solid #2C823D; }';
-    html += 'td { padding: 10px 8px; border: 1px solid #e0e0e0; }';
-    html += 'tr:nth-child(even) { background: #f8f8f8; }';
-    html += 'hr { border: none; border-top: 2px solid #2C823D; margin: 20px 0; }';
-    html += '</style>';
-
-    const processTextNode = (textNode: any): string => {
-      if (!textNode) return '';
-      let text = textNode.text || '';
-      if (textNode.marks) {
-        textNode.marks.forEach((mark: any) => {
-          if (mark.type === 'bold') text = `<strong>${text}</strong>`;
-          if (mark.type === 'italic') text = `<em>${text}</em>`;
-          if (mark.type === 'underline') text = `<u>${text}</u>`;
-        });
-      }
-      return text;
-    };
+        return () => clearTimeout(autoSaveTimer);
+    }, [currentDocId, documents]);
 
-    const processContent = (contentArray: any[]): string => {
-      if (!contentArray) return '';
-      return contentArray.map(processTextNode).join('');
-    };
+    useEffect(() => {
+        if (currentDocId) {
+            localStorage.setItem("currentDocId", currentDocId);
+        }
+    }, [currentDocId]);
 
-    content.content.forEach((node: any) => {
-      switch (node.type) {
-        case 'heading':
-          const level = node.attrs?.level || 1;
-          html += `<h${level}>${processContent(node.content)}</h${level}>`;
-          break;
-        case 'paragraph':
-          html += `<p>${processContent(node.content)}</p>`;
-          break;
-        case 'bulletList':
-          html += '<ul>';
-          node.content?.forEach((item: any) => {
-            const itemContent = item.content?.[0]?.content ? processContent(item.content[0].content) : '';
-            html += `<li>${itemContent}</li>`;
-          });
-          html += '</ul>';
-          break;
-        case 'orderedList':
-          html += '<ol>';
-          node.content?.forEach((item: any) => {
-            const itemContent = item.content?.[0]?.content ? processContent(item.content[0].content) : '';
-            html += `<li>${itemContent}</li>`;
-          });
-          html += '</ol>';
-          break;
-        case 'table':
-          html += '<table>';
-          node.content?.forEach((row: any, rowIndex: number) => {
-            html += '<tr>';
-            row.content?.forEach((cell: any) => {
-              const cellContent = cell.content?.[0]?.content ? processContent(cell.content[0].content) : '';
-              const tag = rowIndex === 0 || cell.type === 'tableHeader' ? 'th' : 'td';
-              html += `<${tag}>${cellContent}</${tag}>`;
-            });
-            html += '</tr>';
-          });
-          html += '</table>';
-          break;
-        case 'horizontalRule':
-          html += '<hr />';
-          break;
-        case 'editablePricingTable':
-          // Render editable pricing table as HTML table for PDF export
-          const rows = node.attrs?.rows || [];
-          const discount = node.attrs?.discount || 0;
-          
-          html += '<h3>Project Pricing</h3>';
-          html += '<table>';
-          html += '<tr><th>Role</th><th>Description</th><th>Hours</th><th>Rate (AUD)</th><th>Cost (AUD)</th></tr>';
-          
-          let subtotal = 0;
-          rows.forEach((row: any) => {
-            const cost = row.hours * row.rate;
-            subtotal += cost;
-            html += `<tr>`;
-            html += `<td>${row.role}</td>`;
-            html += `<td>${row.description}</td>`;
-            html += `<td>${row.hours}</td>`;
-            html += `<td>$${row.rate}</td>`;
-            html += `<td>$${cost.toFixed(2)}</td>`;
-            html += `</tr>`;
-          });
-          
-          html += '</table>';
-          
-          // Summary section
-          html += '<h4 style="margin-top: 20px;">Summary</h4>';
-          html += '<table style="width: auto; margin-left: auto;">';
-          html += `<tr><td style="text-align: right; padding-right: 12px;"><strong>Subtotal:</strong></td><td style="text-align: right;">$${subtotal.toFixed(2)}</td></tr>`;
-          
-          if (discount > 0) {
-            const discountAmount = subtotal * (discount / 100);
-            const afterDiscount = subtotal - discountAmount;
-            html += `<tr><td style="text-align: right; padding-right: 12px; color: #dc2626;"><strong>Discount (${discount}%):</strong></td><td style="text-align: right; color: #dc2626;">-$${discountAmount.toFixed(2)}</td></tr>`;
-            html += `<tr><td style="text-align: right; padding-right: 12px;"><strong>After Discount:</strong></td><td style="text-align: right;">$${afterDiscount.toFixed(2)}</td></tr>`;
-            subtotal = afterDiscount;
-          }
-          
-          const gst = subtotal * 0.1;
-          const total = subtotal + gst;
-          
-          html += `<tr><td style="text-align: right; padding-right: 12px;"><strong>GST (10%):</strong></td><td style="text-align: right;">$${gst.toFixed(2)}</td></tr>`;
-          html += `<tr style="border-top: 2px solid #2C823D;"><td style="text-align: right; padding-right: 12px; padding-top: 8px;"><strong>Total Project Value:</strong></td><td style="text-align: right; padding-top: 8px; color: #2C823D; font-size: 18px;"><strong>$${total.toFixed(2)}</strong></td></tr>`;
-          html += '</table>';
-          break;
-        default:
-          if (node.content) {
-            html += `<p>${processContent(node.content)}</p>`;
-          }
-      }
-    });
+    useEffect(() => {
+        // ðŸŒ± Load GARDNERS from AnythingLLM (not old agents table!)
+        const loadGardnersAsAgents = async () => {
+            try {
+                console.log("ðŸŒ± Loading Gardners from AnythingLLM...");
+                const response = await fetch("/api/gardners/list");
+                if (!response.ok) throw new Error("Failed to load Gardners");
+
+                const { gardners } = await response.json();
+                console.log(
+                    `âœ… Loaded ${gardners.length} Gardners:`,
+                    gardners.map((g: any) => g.name),
+                );
+
+                // Convert Gardners to Agent format for compatibility
+                const gardnerAgents: Agent[] = gardners.map((gardner: any) => ({
+                    id: gardner.slug,
+                    name: gardner.name,
+                    systemPrompt: gardner.systemPrompt || "",
+                    model: "anythingllm", // All Gardners use AnythingLLM
+                }));
+
+                setAgents(gardnerAgents);
+
+                // Set default to "GEN - The Architect" (priority), then any gardner with "gen", then first available
+                const genArchitect = gardnerAgents.find(
+                    (a) =>
+                        a.name === "GEN - The Architect" ||
+                        a.id === "gen-the-architect",
+                );
+                const anyGenGardner = gardnerAgents.find((a) =>
+                    a.id.includes("gen"),
+                );
+                const defaultAgentId =
+                    genArchitect?.id ||
+                    anyGenGardner?.id ||
+                    gardnerAgents[0]?.id ||
+                    "gen-the-architect";
+
+                console.log(
+                    `ðŸŽ¯ [Agent Selection] Default agent set to: ${defaultAgentId}`,
+                );
+
+                // Load current agent preference from database
+                const prefResponse = await fetch(
+                    "/api/preferences/current_agent_id",
+                );
+                if (prefResponse.ok) {
+                    const { value } = await prefResponse.json();
+                    setCurrentAgentId(value || defaultAgentId);
+                } else {
+                    setCurrentAgentId(defaultAgentId);
+                }
+            } catch (error) {
+                console.error("âŒ Failed to load Gardners:", error);
+                // Fallback: show empty state
+                setAgents([]);
+                setCurrentAgentId(null);
+            }
+        };
+
+        loadGardnersAsAgents();
+    }, []);
+
+    // Save current agent preference to database
+    useEffect(() => {
+        if (currentAgentId) {
+            fetch("/api/preferences/current_agent_id", {
+                method: "PUT",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({ value: currentAgentId }),
+            }).catch((err) =>
+                console.error("Failed to save agent preference:", err),
+            );
+        }
+    }, [currentAgentId]);
 
-    return html;
-  };
+    // Chat messages are now saved individually on each message send/receive
+    // No need for useEffect saving here - database handles persistence
 
-  const handleUpdateDoc = (content: any) => {
-    if (currentDocId) {
-      setDocuments(prev => prev.map(d => d.id === currentDocId ? { ...d, content } : d));
-    }
-  };
+    const currentDoc = documents.find((d) => d.id === currentDocId);
 
-  const handleInsertSOWContent = (markdownContent: string) => {
-    if (editorRef.current && markdownContent) {
-      const novelContent = convertMarkdownToNovelJSON(markdownContent);
-      editorRef.current.insertContent(novelContent);
-    }
-  };
-
-  const handleCreateAgent = async (agent: Omit<Agent, 'id'>) => {
-    const newId = `agent${Date.now()}`;
-    const newAgent: Agent = { id: newId, ...agent };
-    
-    try {
-      const response = await fetch('/api/agents', {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify(newAgent)
-      });
-      
-      if (response.ok) {
-        setAgents(prev => [...prev, newAgent]);
-        setCurrentAgentId(newId);
-        console.log('âœ… Agent created in database');
-      }
-    } catch (error) {
-      console.error('âŒ Failed to create agent:', error);
-    }
-  };
-
-  const handleSelectAgent = async (id: string) => {
-    setCurrentAgentId(id);
-    
-    // âš ï¸ REMOVED DATABASE CALLS - AnythingLLM handles message storage via threads
-    // Chat history is maintained by AnythingLLM's workspace threads system
-    // No need to duplicate in MySQL database
-    setChatMessages([]); // Start fresh - AnythingLLM maintains history in its threads
-    
-    console.log(`âœ… Agent selected: ${id}. Chat history managed by AnythingLLM threads.`);
-  };
-
-  const handleUpdateAgent = async (id: string, updates: Partial<Agent>) => {
-    try {
-      const response = await fetch(`/api/agents/${id}`, {
-        method: 'PUT',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify(updates)
-      });
-      
-      if (response.ok) {
-        setAgents(prev => prev.map(a => a.id === id ? { ...a, ...updates } : a));
-        console.log('âœ… Agent updated in database');
-      }
-    } catch (error) {
-      console.error('âŒ Failed to update agent:', error);
-    }
-  };
-
-  const handleDeleteAgent = async (id: string) => {
-    try {
-      const response = await fetch(`/api/agents/${id}`, {
-        method: 'DELETE'
-      });
-      
-      if (response.ok) {
-        setAgents(prev => prev.filter(a => a.id !== id));
-        if (currentAgentId === id) {
-          setCurrentAgentId(null);
-          setChatMessages([]);
+    useEffect(() => {
+        if (currentDoc && editorRef.current) {
+            // Update editor content when document changes
+            editorRef.current.insertContent(currentDoc.content);
         }
-        console.log('âœ… Agent deleted from database (messages cascade deleted)');
-      }
-    } catch (error) {
-      console.error('âŒ Failed to delete agent:', error);
-    }
-  };
-
-  const handleInsertContent = async (content: string) => {
-    console.log('ðŸ“ Inserting content into editor:', content.substring(0, 100));
-    console.log('ðŸ“ Editor ref exists:', !!editorRef.current);
-    console.log('ðŸ“„ Current doc ID:', currentDocId);
-    
-    if (!content || !currentDocId) {
-      console.error('âŒ Missing content or document ID');
-      return;
-    }
+    }, [currentDocId, currentDoc]);
+
+    const handleSelectDoc = (id: string) => {
+        setCurrentDocId(id);
+        // Clear chat messages for clean state when switching documents
+        setChatMessages([]);
+        // Switch to editor view when selecting a document
+        if (viewMode !== "editor") {
+            setViewMode("editor");
+        }
+    };
+
+    const handleNewDoc = async (folderId?: string) => {
+        const newId = `doc${Date.now()}`;
+        const title = "New SOW";
+
+        // Find workspace slug from the folder this SOW belongs to
+        const parentFolder = folderId
+            ? folders.find((f) => f.id === folderId)
+            : null;
+        const workspaceSlug = parentFolder?.workspaceSlug;
+
+        let newDoc: Document = {
+            id: newId,
+            title,
+            content: defaultEditorContent,
+            folderId,
+            workspaceSlug,
+        };
 
-    try {
-      // Clean the content first - remove non-client-facing elements
-      console.log('ðŸ§¹ Cleaning SOW content...');
-      const cleanedContent = cleanSOWContent(content);
-      console.log('âœ… Content cleaned');
-      
-      // Convert markdown content to Novel editor JSON format
-      console.log('ðŸ”„ Converting markdown to JSON...');
-      const convertedContent = convertMarkdownToNovelJSON(cleanedContent);
-      console.log('âœ… Content converted');
-      
-      // Extract title from the content (first heading)
-      const titleMatch = cleanedContent.match(/^#\s+(.+)$/m);
-      const clientMatch = cleanedContent.match(/\*\*Client:\*\*\s+(.+)$/m);
-      const scopeMatch = cleanedContent.match(/Scope of Work:\s+(.+)/);
-      
-      let docTitle = "New SOW";
-      if (titleMatch) {
-        docTitle = titleMatch[1];
-      } else if (scopeMatch) {
-        docTitle = scopeMatch[1];
-      } else if (clientMatch) {
-        docTitle = `SOW - ${clientMatch[1]}`;
-      }
-      
-      // Update the document with new content and title
-      console.log('ðŸ“ Updating document:', docTitle);
-      setDocuments(prev =>
-        prev.map(doc =>
-          doc.id === currentDocId
-            ? { ...doc, content: convertedContent, title: docTitle }
-            : doc
-        )
-      );
-      console.log('âœ… Document updated successfully');
-      
-      // Also update the editor directly
-      if (editorRef.current) {
-        editorRef.current.insertContent(convertedContent);
-      }
-      
-      // Embed SOW in both client workspace and master dashboard
-      const currentAgent = agents.find(a => a.id === currentAgentId);
-      const useAnythingLLM = currentAgent?.model === 'anythingllm';
-      
-      if (useAnythingLLM && currentAgentId) {
-        console.log('ðŸ¤– Embedding SOW in workspaces...');
         try {
-          const clientWorkspaceSlug = getWorkspaceForAgent(currentAgentId);
-          // Fixed parameter order: (workspaceSlug, title, content)
-          const success = await anythingLLM.embedSOWInBothWorkspaces(clientWorkspaceSlug, docTitle, cleanedContent);
-          
-          if (success) {
-            console.log('âœ… SOW embedded in both workspaces successfully');
-            toast.success("âœ… Content inserted and embedded in both workspaces!");
-          } else {
-            console.warn('âš ï¸ Embedding completed with warnings');
-            toast.success("âœ… Content inserted to editor (workspace embedding had issues)");
-          }
-        } catch (embedError) {
-          console.error('âš ï¸ Embedding error:', embedError);
-          toast.success("âœ… Content inserted to editor (embedding skipped)");
-        }
-      } else {
-        toast.success("âœ… Content inserted into editor!");
-      }
-    } catch (error) {
-      console.error("Error inserting content:", error);
-      toast.error("âŒ Failed to insert content. Please try again.");
-    }
-  };
-
-  const [currentRequestController, setCurrentRequestController] = useState<AbortController | null>(null);
-  const [lastMessageSentTime, setLastMessageSentTime] = useState<number>(0);
-  const MESSAGE_RATE_LIMIT = 1000; // Wait at least 1 second between messages to avoid rate limiting
-
-  const handleSendMessage = async (message: string) => {
-    // In dashboard mode, we don't need an agent selected - use dashboard workspace directly
-    const isDashboardMode = viewMode === 'dashboard';
-    
-    if (!message.trim()) return;
-    if (!isDashboardMode && !currentAgentId) return; // Only require agent in editor mode
-
-    // Rate limiting: prevent sending messages too quickly
-    const now = Date.now();
-    if (now - lastMessageSentTime < MESSAGE_RATE_LIMIT) {
-      console.warn(`â±ï¸ Rate limit: Please wait before sending another message. (${Math.ceil((MESSAGE_RATE_LIMIT - (now - lastMessageSentTime)) / 1000)}s)`);
-      toast.error("â±ï¸ Please wait a moment before sending another message.");
-      return;
-    }
-    setLastMessageSentTime(now);
+            // ðŸ§µ Create AnythingLLM thread for this SOW (if workspace exists)
+            if (workspaceSlug) {
+                console.log(
+                    `ðŸ”— Creating thread in workspace: ${workspaceSlug}`,
+                );
+                // Don't pass thread name - AnythingLLM auto-names based on first chat message
+                const thread = await anythingLLM.createThread(workspaceSlug);
+                if (thread) {
+                    newDoc = {
+                        ...newDoc,
+                        threadSlug: thread.slug,
+                        threadId: thread.id,
+                        syncedAt: new Date().toISOString(),
+                    };
+
+                    // ðŸ“Š Embed SOW in BOTH client workspace AND master dashboard
+                    console.log(
+                        `ðŸ“Š Embedding new SOW in both workspaces: ${workspaceSlug}`,
+                    );
+                    const sowContent = JSON.stringify(defaultEditorContent);
+                    await anythingLLM.embedSOWInBothWorkspaces(
+                        workspaceSlug,
+                        title,
+                        sowContent,
+                    );
 
-    // Cancel any previous ongoing request to avoid flooding the API
-    if (currentRequestController) {
-      console.log('ðŸ›‘ Cancelling previous request to avoid rate limiting...');
-      currentRequestController.abort();
-    }
+                    toast.success(
+                        `âœ… SOW created with chat thread in ${parentFolder?.name || "workspace"}`,
+                    );
+                } else {
+                    console.warn(
+                        "âš ï¸ Thread creation failed - SOW created without thread",
+                    );
+                    toast.warning(
+                        "âš ï¸ SOW created but thread sync failed. You can still chat about it.",
+                    );
+                }
+            } else {
+                console.log("â„¹ï¸ No workspace found - creating standalone SOW");
+                toast.info(
+                    "â„¹ï¸ SOW created outside a folder. Create a folder first to enable AI chat.",
+                );
+            }
+        } catch (error) {
+            console.error("âŒ Error creating thread:", error);
+            toast.error("SOW created but thread sync failed");
+        }
 
-    // Create new AbortController for this request
-    const controller = new AbortController();
-    setCurrentRequestController(controller);
-
-    setIsChatLoading(true);
-
-    // Check for insert command (only relevant in editor mode)
-    if (!isDashboardMode && (
-        message.toLowerCase().includes('insert into editor') ||
-        message.toLowerCase() === 'insert' ||
-        message.toLowerCase().includes('add to editor')
-    )) {
-      console.log('ðŸ“ Insert command detected!', { message });
-      setIsChatLoading(false);
-      
-      // Find the last AI response in chat history (excluding confirmation messages)
-      const lastAIMessage = [...chatMessages].reverse().find(msg => 
-        msg.role === 'assistant' && 
-        !msg.content.includes('âœ… SOW has been inserted') &&
-        !msg.content.includes('Ready to insert')
-      );
-      
-      console.log('ðŸ“‹ Found AI message:', lastAIMessage?.content.substring(0, 100));
-      console.log('ðŸ“ Editor ref exists:', !!editorRef.current);
-      console.log('ðŸ“„ Current doc ID:', currentDocId);
-      
-      if (lastAIMessage && currentDocId) {
+        // Save new SOW to database first
         try {
-          // Clean the content first - remove non-client-facing elements
-          console.log('ðŸ§¹ Cleaning SOW content...');
-          const cleanedMessage = cleanSOWContent(lastAIMessage.content);
-          console.log('âœ… Content cleaned');
-          
-          // Convert markdown content to Novel editor JSON format
-          console.log('ðŸ”„ Converting markdown to JSON...');
-          const content = convertMarkdownToNovelJSON(cleanedMessage);
-          console.log('âœ… Content converted');
-          
-          // Extract title from the SOW content (first heading)
-          const titleMatch = cleanedMessage.match(/^#\s+(.+)$/m);
-          const clientMatch = cleanedMessage.match(/\*\*Client:\*\*\s+(.+)$/m);
-          const scopeMatch = cleanedMessage.match(/Scope of Work:\s+(.+)/);
-          
-          let docTitle = "New SOW";
-          if (titleMatch) {
-            docTitle = titleMatch[1];
-          } else if (scopeMatch) {
-            docTitle = scopeMatch[1];
-          } else if (clientMatch) {
-            docTitle = `SOW - ${clientMatch[1]}`;
-          }
-          
-          // Update the document with new content and title
-          console.log('ðŸ“ Updating document:', docTitle);
-          setDocuments(prev =>
-            prev.map(doc =>
-              doc.id === currentDocId
-                ? { ...doc, content, title: docTitle }
-                : doc
-            )
-          );
-          console.log('âœ… Document updated successfully');
-          
-          // ðŸ’¾ SAVE TO DATABASE
-          console.log('ðŸ’¾ Saving SOW to database...');
-          try {
-            const saveResponse = await fetch('/api/sow/update', {
-              method: 'PUT',
-              headers: { 'Content-Type': 'application/json' },
-              body: JSON.stringify({
-                id: currentDocId,
-                title: docTitle,
-                content: JSON.stringify(content),
-              }),
+            const saveResponse = await fetch("/api/sow/create", {
+                method: "POST",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({
+                    title: newDoc.title,
+                    content: newDoc.content,
+                    folder_id: newDoc.folderId,
+                    workspace_slug: newDoc.workspaceSlug,
+                    client_name: "",
+                    client_email: "",
+                    total_investment: 0,
+                }),
             });
-            
+
             if (saveResponse.ok) {
-              console.log('âœ… SOW saved to database successfully');
+                const savedDoc = await saveResponse.json();
+                // Update newDoc with the database ID
+                newDoc = { ...newDoc, id: savedDoc.id || newId };
+                console.log("âœ… SOW saved to database with id:", newDoc.id);
             } else {
-              console.warn('âš ï¸ Failed to save SOW to database');
-            }
-          } catch (saveError) {
-            console.error('âŒ Database save error:', saveError);
-          }
-          
-          // Also update the editor directly
-          if (editorRef.current) {
-            editorRef.current.insertContent(content);
-          }
-          
-          // Embed SOW in both client workspace and master dashboard
-          const currentAgent = agents.find(a => a.id === currentAgentId);
-          const useAnythingLLM = currentAgent?.model === 'anythingllm';
-          
-          if (useAnythingLLM && currentAgentId) {
-            console.log('ðŸ¤– Embedding SOW in AnythingLLM workspaces...');
-            try {
-              const clientWorkspaceSlug = getWorkspaceForAgent(currentAgentId);
-              // Fixed parameter order: (workspaceSlug, title, content)
-              const success = await anythingLLM.embedSOWInBothWorkspaces(clientWorkspaceSlug, docTitle, cleanedMessage);
-              
-              if (success) {
-                console.log('âœ… SOW embedded in both AnythingLLM workspaces');
-              }
-            } catch (embedError) {
-              console.error('âš ï¸ AnythingLLM embedding error:', embedError);
+                console.warn("âš ï¸ Failed to save SOW to database");
+                toast.warning("âš ï¸ SOW created but not saved to database");
             }
-          }
-          
-          // Add confirmation message
-          const confirmMessage: ChatMessage = {
-            id: `msg${Date.now()}`,
-            role: 'assistant',
-            content: "âœ… SOW has been inserted into the editor, saved to database, and embedded in AnythingLLM!",
-            timestamp: Date.now(),
-          };
-          setChatMessages(prev => [...prev, confirmMessage]);
-          
-          return;
         } catch (error) {
-          console.error("Error inserting content:", error);
-          const errorMessage: ChatMessage = {
-            id: `msg${Date.now()}`,
-            role: 'assistant',
-            content: "âŒ Error inserting content into editor. Please try again.",
-            timestamp: Date.now(),
-          };
-          setChatMessages(prev => [...prev, errorMessage]);
-          
-          // âš ï¸ REMOVED DATABASE SAVE - AnythingLLM handles all message storage
-          return;
+            console.error("âŒ Error saving SOW to database:", error);
+            toast.error("âš ï¸ Failed to save SOW");
         }
-      }
-    }
-
-    // ðŸŽ¯ AUTO-DETECT CLIENT NAME from user prompt
-    const detectedClientName = extractClientName(message);
-    if (detectedClientName && currentDocId) {
-      console.log('ðŸ¢ Detected client name in prompt:', detectedClientName);
-      
-      // Auto-rename SOW to include client name
-      const newSOWTitle = `SOW - ${detectedClientName}`;
-      
-      // Update document title in state
-      setDocuments(prev =>
-        prev.map(doc =>
-          doc.id === currentDocId
-            ? { ...doc, title: newSOWTitle }
-            : doc
-        )
-      );
-      
-      // Save to database
-      fetch('/api/sow/update', {
-        method: 'PUT',
-        headers: { 'Content-Type': 'application/json' },
-        body: JSON.stringify({
-          id: currentDocId,
-          title: newSOWTitle,
-          clientName: detectedClientName,
-        }),
-      }).catch(err => console.error('âŒ Failed to auto-rename SOW:', err));
-      
-      console.log('âœ… Auto-renamed SOW to:', newSOWTitle);
-      toast.success(`ðŸ¢ Auto-detected client: ${detectedClientName}`);
-    }
 
-    const userMessage: ChatMessage = {
-      id: `msg${Date.now()}`,
-      role: 'user',
-      content: message,
-      timestamp: Date.now(),
-    };
+        setDocuments((prev) => [...prev, newDoc]);
+        setCurrentDocId(newDoc.id);
 
-    const newMessages = [...chatMessages, userMessage];
-    setChatMessages(newMessages);
-    
-    // âš ï¸ REMOVED DATABASE SAVE - AnythingLLM handles all message storage
-
-    const currentAgent = agents.find(a => a.id === currentAgentId);
-    
-    // In dashboard mode, we use a simulated agent configuration with OpenRouter
-    // ðŸ”§ Changed from 'anythingllm' to use OpenRouter directly (no RAG needed)
-    const effectiveAgent = isDashboardMode ? {
-      id: 'dashboard',
-      name: 'Dashboard AI',
-      systemPrompt: 'You are a helpful AI assistant for the Social Garden SOW Generator platform. You help users with creating SOWs, understanding features, and general questions. Be helpful, friendly, and concise.',
-      model: 'anythingllm' // âœ… Use AnythingLLM for dashboard (routes to master-dashboard workspace)
-    } : currentAgent;
-    
-    if (effectiveAgent) {
-      try {
-        const useAnythingLLM = effectiveAgent.model === 'anythingllm';
-        
-        // ðŸŽ¯ WORKSPACE SELECTOR ROUTING:
-        // Master View â†’ /api/dashboard/chat (hardcoded to sow-master-dashboard-54307162)
-        // Client Workspace â†’ /api/anythingllm/chat (with selected workspace slug)
-        // Editor Mode â†’ existing logic
-        let endpoint: string;
-        let workspaceSlug: string | undefined;
-
-        if (isDashboardMode && useAnythingLLM) {
-          // Dashboard mode routing
-          if (dashboardChatTarget === 'sow-master-dashboard') {
-            // Master view: use dedicated dashboard route
-            endpoint = '/api/anythingllm/stream-chat';
-            workspaceSlug = 'sow-master-dashboard';
-          } else {
-            // Client-specific view: use general AnythingLLM route with workspace slug
-            endpoint = '/api/anythingllm/chat';
-            workspaceSlug = dashboardChatTarget;
-          }
-        } else {
-          // Editor mode routing (existing logic)
-          endpoint = useAnythingLLM ? '/api/anythingllm/chat' : '/api/chat';
-          workspaceSlug = useAnythingLLM && !isDashboardMode 
-            ? getWorkspaceForAgent(currentAgentId || '') 
-            : undefined;
+        // ðŸŽ¯ Switch to editor view (in case we're on dashboard/AI management)
+        if (viewMode !== "editor") {
+            setViewMode("editor");
         }
 
-        // ðŸŽ¯ USE THE SOW'S ACTUAL WORKSPACE (NOT FORCED GEN-THE-ARCHITECT)
-        // Each SOW has its thread in its client workspace (e.g., "hello", "pho", etc.)
-        // Don't force gen-the-architect - that breaks thread routing!
-        if (!isDashboardMode && useAnythingLLM && currentSOWId) {
-          const currentSOW = documents.find(d => d.id === currentSOWId);
-          if (currentSOW?.workspaceSlug) {
-            workspaceSlug = currentSOW.workspaceSlug; // Use the SOW's actual workspace
-            console.log(`ðŸŽ¯ [SOW Chat] Using SOW workspace: ${workspaceSlug}`);
-          }
+        // Clear chat messages for current agent (in state only - database messages persist)
+        setChatMessages([]);
+
+        // Keep sidebar closed - let user open manually
+        const architectAgent = agents.find((a) => a.id === "architect");
+        if (architectAgent) {
+            setCurrentAgentId("architect");
         }
+    };
 
-        console.log('ðŸŽ¯ [Chat Routing]', {
-          isDashboardMode,
-          useAnythingLLM,
-          dashboardChatTarget,
-          endpoint,
-          workspaceSlug,
-          agentModel: effectiveAgent.model,
-          agentName: effectiveAgent.name,
-          routeType: isDashboardMode 
-            ? (dashboardChatTarget === 'sow-master-dashboard' ? 'MASTER_DASHBOARD' : 'CLIENT_WORKSPACE')
-            : 'SOW_GENERATION'
-        });
+    const handleRenameDoc = async (id: string, title: string) => {
+        const doc = documents.find((d) => d.id === id);
 
-        // ðŸŒŠ STREAMING SUPPORT: Use stream-chat endpoint for AnythingLLM
-        const shouldStream = useAnythingLLM;
-        const streamEndpoint = endpoint.includes('/stream-chat') ? endpoint : endpoint.replace('/chat', '/stream-chat');
-        
-        if (shouldStream) {
-          // âœ¨ STREAMING MODE: Real-time response with thinking display
-          const aiMessageId = `msg${Date.now() + 1}`;
-          let accumulatedContent = '';
-          
-          // Create initial empty AI message
-          const initialAIMessage: ChatMessage = {
-            id: aiMessageId,
-            role: 'assistant',
-            content: '',
-            timestamp: Date.now(),
-          };
-          setChatMessages(prev => [...prev, initialAIMessage]);
-          setStreamingMessageId(aiMessageId);
-
-          const response = await fetch(streamEndpoint, {
-            method: "POST",
-            headers: {
-              "Content-Type": "application/json",
-            },
-            signal: controller.signal, // ðŸ›‘ Allow cancellation of this request
-            body: JSON.stringify({
-              model: effectiveAgent.model,
-              workspace: workspaceSlug,
-              threadSlug: !isDashboardMode && currentDocId ? (documents.find(d => d.id === currentDocId)?.threadSlug || undefined) : undefined,
-              messages: [
-                { role: "system", content: effectiveAgent.systemPrompt },
-                ...newMessages.map(m => ({ role: m.role, content: m.content })),
-              ],
-            }),
-          });
-
-          if (!response.ok) {
-            const errorText = await response.text();
-            let errorMessage = "Sorry, there was an error processing your request.";
-
-            if (response.status === 400) {
-              errorMessage = "âš ï¸ AnythingLLM error: Invalid request. Please check the workspace configuration.";
-            } else if (response.status === 401 || response.status === 403) {
-              errorMessage = "âš ï¸ AnythingLLM authentication failed. Please check the API key configuration.";
-            } else if (response.status === 404) {
-              errorMessage = `âš ï¸ AnythingLLM workspace '${workspaceSlug}' not found. Please verify it exists.`;
+        try {
+            // ðŸ§µ Update AnythingLLM thread name if it exists
+            if (doc?.workspaceSlug && doc?.threadSlug) {
+                await anythingLLM.updateThread(
+                    doc.workspaceSlug,
+                    doc.threadSlug,
+                    title,
+                );
+                toast.success(`âœ… SOW renamed to "${title}"`);
             }
 
-            setChatMessages(prev => 
-              prev.map(msg => msg.id === aiMessageId 
-                ? { ...msg, content: errorMessage }
-                : msg
-              )
+            setDocuments((prev) =>
+                prev.map((d) =>
+                    d.id === id
+                        ? { ...d, title, syncedAt: new Date().toISOString() }
+                        : d,
+                ),
             );
-            setStreamingMessageId(null);
-            return;
-          }
-
-          // Read the SSE stream
-          const reader = response.body?.getReader();
-          const decoder = new TextDecoder();
+        } catch (error) {
+            console.error("Error renaming document:", error);
+            setDocuments((prev) =>
+                prev.map((d) => (d.id === id ? { ...d, title } : d)),
+            );
+            toast.error("SOW renamed locally but thread sync failed");
+        }
+    };
 
-          if (!reader) {
-            console.error('âŒ No response body reader available');
-            setStreamingMessageId(null);
-            return;
-          }
-
-          try {
-            let buffer = '';
-            while (true) {
-              const { done, value } = await reader.read();
-              
-              if (done) {
-                console.log('âœ… Stream complete');
-                setStreamingMessageId(null);
-                break;
-              }
+    const handleDeleteDoc = async (id: string) => {
+        const doc = documents.find((d) => d.id === id);
 
-              buffer += decoder.decode(value, { stream: true });
-              const lines = buffer.split('\n');
-              buffer = lines.pop() || '';
+        try {
+            // Delete SOW from database first
+            const deleteResponse = await fetch(`/api/sow/${id}`, {
+                method: "DELETE",
+                headers: { "Content-Type": "application/json" },
+            });
 
-              for (const line of lines) {
-                if (!line.trim() || !line.startsWith('data: ')) continue;
-                
-                try {
-                  const jsonStr = line.substring(6); // Remove 'data: ' prefix
-                  const data = JSON.parse(jsonStr);
-                  
-                  // Handle different message types from AnythingLLM stream
-                  if (data.type === 'textResponseChunk' && data.textResponse) {
-                    accumulatedContent += data.textResponse;
-                    
-                    // Update the message content in real-time
-                    setChatMessages(prev =>
-                      prev.map(msg =>
-                        msg.id === aiMessageId
-                          ? { ...msg, content: accumulatedContent }
-                          : msg
-                      )
-                    );
-                  } else if (data.type === 'textResponse') {
-                    // Final response (fallback for non-chunked)
-                    accumulatedContent = data.content || data.textResponse || '';
-                    setChatMessages(prev =>
-                      prev.map(msg =>
-                        msg.id === aiMessageId
-                          ? { ...msg, content: accumulatedContent }
-                          : msg
-                      )
-                    );
-                  }
-                } catch (parseError) {
-                  console.error('Failed to parse SSE data:', parseError);
-                }
-              }
-            }
-          } catch (streamError) {
-            console.error('âŒ Stream reading error:', streamError);
-            setStreamingMessageId(null);
-          }
-
-          console.log('âœ… Streaming complete, total content length:', accumulatedContent.length);
-          
-          // ðŸŽ¯ Extract work type from the accumulated AI response
-          const detectedWorkType = extractWorkType(accumulatedContent);
-          
-          // Update current document with detected work type
-          if (currentDocId && detectedWorkType) {
-            setDocuments(prev => 
-              prev.map(doc => 
-                doc.id === currentDocId 
-                  ? { ...doc, workType: detectedWorkType }
-                  : doc
-              )
-            );
-            console.log(`ðŸŽ¯ Updated document ${currentDocId} with work type: ${detectedWorkType}`);
-          }
-        } else {
-          // ðŸ“¦ NON-STREAMING MODE: Standard fetch for OpenRouter
-          const response = await fetch(endpoint, {
-            method: "POST",
-            headers: {
-              "Content-Type": "application/json",
-            },
-            signal: controller.signal, // ðŸ›‘ Allow cancellation of this request
-            body: JSON.stringify({
-              model: effectiveAgent.model,
-              workspace: workspaceSlug,
-              threadSlug: !isDashboardMode && currentDocId ? (documents.find(d => d.id === currentDocId)?.threadSlug || undefined) : undefined,
-              messages: [
-                { role: "system", content: effectiveAgent.systemPrompt },
-                ...newMessages.map(m => ({ role: m.role, content: m.content })),
-              ],
-            }),
-          });
-
-          console.log('ðŸ“¥ Response Status:', response.status, response.statusText);
-          const data = await response.json();
-
-          if (!response.ok) {
-            let errorMessage = "Sorry, there was an error processing your request.";
-
-            if (response.status === 400) {
-              errorMessage = "âš ï¸ OpenRouter API key not configured. Please set the OPENROUTER_API_KEY environment variable to enable AI chat functionality.";
-            } else if (response.status === 402) {
-              errorMessage = "Payment required: Please check your OpenRouter account balance or billing information.";
-            } else if (response.status === 401) {
-              errorMessage = "Authentication failed: Please check your OpenRouter API key.";
-            } else if (response.status === 429) {
-              errorMessage = "Rate limit exceeded: Please wait a moment before trying again.";
-            } else if (data.error?.message) {
-              errorMessage = `API Error: ${data.error.message}`;
+            if (deleteResponse.ok) {
+                console.log("âœ… SOW deleted from database:", id);
+            } else {
+                console.warn("âš ï¸ Failed to delete SOW from database");
+                toast.warning(
+                    "âš ï¸ SOW deleted from UI but database deletion failed",
+                );
             }
 
-            const aiMessage: ChatMessage = {
-              id: `msg${Date.now() + 1}`,
-              role: 'assistant',
-              content: errorMessage,
-              timestamp: Date.now(),
-            };
-            setChatMessages(prev => [...prev, aiMessage]);
-            return;
-          }
-
-          const aiMessage: ChatMessage = {
-            id: `msg${Date.now() + 1}`,
-            role: 'assistant',
-            content: data.choices?.[0]?.message?.content || "Sorry, I couldn't generate a response.",
-            timestamp: Date.now(),
-          };
-          setChatMessages(prev => [...prev, aiMessage]);
-          console.log('âœ… Non-streaming response complete');
-        }
-      } catch (error) {
-        console.error("âŒ Chat API error:", error);
-        
-        // Check if the error is an AbortError (request was cancelled)
-        if (error instanceof Error && error.name === 'AbortError') {
-          console.log('â„¹ï¸ Request was cancelled to prevent rate limiting');
-          return;
+            // ðŸ§µ Delete AnythingLLM thread if it exists
+            if (doc?.workspaceSlug && doc?.threadSlug) {
+                await anythingLLM.deleteThread(
+                    doc.workspaceSlug,
+                    doc.threadSlug,
+                );
+                toast.success(`âœ… SOW and thread deleted`);
+            }
+        } catch (error) {
+            console.error("Error deleting SOW:", error);
+            toast.error("Failed to delete SOW");
         }
 
-        // Check for rate limiting errors
-        let errorMessage = "âŒ Network error: Unable to reach AI service. Please check your connection and try again.";
-        if (error instanceof Error && error.message.includes('429')) {
-          errorMessage = "â±ï¸ Rate limit exceeded: Please wait a moment before trying again.";
-          toast.error("â±ï¸ Rate limited - waiting before retry...");
+        setDocuments((prev) => prev.filter((d) => d.id !== id));
+        if (currentDocId === id) {
+            const remaining = documents.filter((d) => d.id !== id);
+            setCurrentDocId(remaining.length > 0 ? remaining[0].id : null);
         }
+    };
 
-        const errorMsg: ChatMessage = {
-          id: `msg${Date.now() + 1}`,
-          role: 'assistant',
-          content: errorMessage,
-          timestamp: Date.now(),
+    const handleNewFolder = async (name: string) => {
+        const newId = `folder-${Date.now()}`;
+        try {
+            // ðŸ¢ Create AnythingLLM workspace for this folder
+            const workspace =
+                await anythingLLM.createOrGetClientWorkspace(name);
+            const embedId = await anythingLLM.getOrCreateEmbedId(
+                workspace.slug,
+            );
+
+            // ðŸ’¾ Save folder to DATABASE
+            const response = await fetch("/api/folders", {
+                method: "POST",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({
+                    id: newId,
+                    name,
+                    workspaceSlug: workspace.slug,
+                    workspaceId: workspace.id,
+                    embedId: embedId,
+                }),
+            });
+
+            if (!response.ok) {
+                const errorData = await response.json();
+                throw new Error(
+                    errorData.details || "Failed to create folder in database",
+                );
+            }
+
+            const savedFolder = await response.json();
+            console.log("âœ… Folder saved to database:", savedFolder);
+
+            const newFolder: Folder = {
+                id: savedFolder.id,
+                name: name,
+                workspaceSlug: workspace.slug,
+                workspaceId: workspace.id,
+                embedId,
+                syncedAt: new Date().toISOString(),
+            };
+
+            setFolders((prev) => [...prev, newFolder]);
+            toast.success(`âœ… Workspace "${name}" created!`);
+
+            // ðŸŽ¯ AUTO-CREATE FIRST SOW IN NEW FOLDER
+            // This creates an empty SOW and opens it immediately
+            await handleNewDoc(newFolder.id);
+        } catch (error) {
+            console.error("Error creating folder:", error);
+            toast.error(`âŒ Failed to create folder: ${error.message}`);
+        }
+    };
+
+    const handleRenameFolder = async (id: string, name: string) => {
+        const folder = folders.find((f) => f.id === id);
+
+        try {
+            // ðŸ’¾ Update folder in DATABASE
+            const response = await fetch(`/api/folders/${id}`, {
+                method: "PUT",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({ name }),
+            });
+
+            if (!response.ok) {
+                throw new Error("Failed to update folder in database");
+            }
+
+            // ðŸ¢ Update AnythingLLM workspace name if it exists
+            if (folder?.workspaceSlug) {
+                await anythingLLM.updateWorkspace(folder.workspaceSlug, name);
+            }
+
+            setFolders((prev) =>
+                prev.map((f) =>
+                    f.id === id
+                        ? { ...f, name, syncedAt: new Date().toISOString() }
+                        : f,
+                ),
+            );
+            toast.success(`âœ… Folder renamed to "${name}"`);
+        } catch (error) {
+            console.error("Error renaming folder:", error);
+            toast.error("âŒ Failed to rename folder");
+        }
+    };
+
+    const handleDeleteFolder = async (id: string) => {
+        const folder = folders.find((f) => f.id === id);
+
+        // Also delete subfolders and docs in folder
+        const toDelete = [id];
+        const deleteRecursive = (folderId: string) => {
+            folders
+                .filter((f) => f.parentId === folderId)
+                .forEach((f) => {
+                    toDelete.push(f.id);
+                    deleteRecursive(f.id);
+                });
         };
-        const updatedMessages = [...newMessages, errorMsg];
-        setChatMessages(updatedMessages);
-        
-        // âš ï¸ REMOVED DATABASE SAVE - AnythingLLM handles all message storage
-      } finally {
-        setIsChatLoading(false);
-        setCurrentRequestController(null); // Clean up the controller
-      }
-    } else {
-      setIsChatLoading(false);
-    }
-  };
+        deleteRecursive(id);
 
-  // Prevent hydration errors by not rendering until mounted
-  if (!mounted) {
-    return null;
-  }
-
-  return (
-    <div className="flex flex-col h-screen bg-[#0e0f0f]">
-      {/* Onboarding Tutorial */}
-      <InteractiveOnboarding />
-      
-      {/* Resizable Layout with Sidebar, Editor, and AI Chat */}
-      <div className="flex-1 h-full overflow-hidden">
-        <ResizableLayout
-        sidebarOpen={sidebarOpen}
-        aiChatOpen={agentSidebarOpen}
-        onToggleSidebar={() => setSidebarOpen(!sidebarOpen)}
-        onToggleAiChat={() => setAgentSidebarOpen(!agentSidebarOpen)}
-        viewMode={viewMode} // Pass viewMode for context awareness
-        leftPanel={
-          // Always show sidebar navigation regardless of view mode
-          <SidebarNav
-            workspaces={workspaces}
-            currentWorkspaceId={currentWorkspaceId}
-            currentSOWId={currentSOWId}
-            currentView={viewMode}
-            onSelectWorkspace={setCurrentWorkspaceId}
-            onSelectSOW={setCurrentSOWId}
-            onCreateWorkspace={handleCreateWorkspace}
-            onRenameWorkspace={handleRenameWorkspace}
-            onDeleteWorkspace={handleDeleteWorkspace}
-            onCreateSOW={handleCreateSOW}
-            onRenameSOW={handleRenameSOW}
-            onDeleteSOW={handleDeleteSOW}
-            onViewChange={handleViewChange}
-            onToggleSidebar={() => setSidebarOpen(!sidebarOpen)}
-            onReorderWorkspaces={handleReorderWorkspaces}
-            onReorderSOWs={handleReorderSOWs}
-          />
+        try {
+            // ðŸ’¾ Delete folder from DATABASE
+            const response = await fetch(`/api/folders/${id}`, {
+                method: "DELETE",
+            });
+
+            if (!response.ok) {
+                throw new Error("Failed to delete folder from database");
+            }
+
+            // ðŸ¢ Delete AnythingLLM workspace (cascades to all threads)
+            if (folder?.workspaceSlug) {
+                await anythingLLM.deleteWorkspace(folder.workspaceSlug);
+            }
+
+            setFolders((prev) => prev.filter((f) => !toDelete.includes(f.id)));
+            setDocuments((prev) =>
+                prev.filter(
+                    (d) => !d.folderId || !toDelete.includes(d.folderId),
+                ),
+            );
+            toast.success(`âœ… Folder deleted from database`);
+        } catch (error) {
+            console.error("Error deleting folder:", error);
+            toast.error("âŒ Failed to delete folder");
         }
-        mainPanel={
-          viewMode === 'editor' ? (
-            <div className="w-full h-full flex flex-col">
-              {/* Document Status Bar - Only show when document is open */}
-              {currentDoc && (
-                <DocumentStatusBar
-                  title={currentDoc.title || "Untitled Statement of Work"}
-                  saveStatus="saved"
-                  isSaving={false}
-                  onExportPDF={handleExportPDF}
-                  onExportExcel={handleCreateGSheet}
-                  onSharePortal={async () => {
-                    if (!currentDoc) {
-                      toast.error('âŒ No document selected');
-                      return;
+    };
+
+    const handleMoveDoc = (docId: string, folderId?: string) => {
+        setDocuments((prev) =>
+            prev.map((d) => (d.id === docId ? { ...d, folderId } : d)),
+        );
+    };
+
+    // ==================== WORKSPACE & SOW HANDLERS (NEW) ====================
+    const handleCreateWorkspace = async (
+        workspaceName: string,
+        workspaceType: "sow" | "client" | "generic" = "sow",
+    ) => {
+        try {
+            console.log("ðŸ“ Creating workspace:", workspaceName);
+
+            // ðŸ“Š SHOW PROGRESS MODAL
+            setWorkspaceCreationProgress({
+                isOpen: true,
+                workspaceName,
+                currentStep: 0,
+                completedSteps: [],
+            });
+
+            // ðŸ¢ STEP 1: Create AnythingLLM workspace FIRST
+            console.log("ðŸ¢ Creating AnythingLLM workspace...");
+            const workspace =
+                await anythingLLM.createOrGetClientWorkspace(workspaceName);
+            const embedId = await anythingLLM.getOrCreateEmbedId(
+                workspace.slug,
+            );
+            console.log("âœ… AnythingLLM workspace created:", workspace.slug);
+
+            // ðŸ§  STEP 1b: Configure workspace with The Architect system prompt (SOW type only)
+            if (workspaceType === "sow") {
+                console.log(
+                    "ðŸ§  Configuring SOW workspace with The Architect system prompt...",
+                );
+                try {
+                    const updateResponse = await fetch(
+                        `${process.env.NEXT_PUBLIC_ANYTHINGLLM_URL}/api/v1/workspace/${workspace.slug}/update`,
+                        {
+                            method: "POST",
+                            headers: {
+                                Authorization: `Bearer ${process.env.ANYTHINGLLM_API_KEY}`,
+                                "Content-Type": "application/json",
+                            },
+                            body: JSON.stringify({
+                                openAiPrompt: THE_ARCHITECT_SYSTEM_PROMPT,
+                                openAiTemp: 0.7,
+                                openAiHistory: 25,
+                            }),
+                        },
+                    );
+
+                    if (!updateResponse.ok) {
+                        const errorText = await updateResponse.text();
+                        console.error(
+                            "âš ï¸ Failed to configure workspace system prompt:",
+                            errorText,
+                        );
+                    } else {
+                        console.log(
+                            "âœ… Workspace configured with The Architect system prompt",
+                        );
                     }
+                } catch (error) {
+                    console.error("âš ï¸ Error configuring workspace:", error);
+                }
+            } else {
+                console.log(
+                    `âœ… Workspace created as ${workspaceType} type (no custom prompt applied)`,
+                );
+            }
+
+            // Mark step 1 complete
+            setWorkspaceCreationProgress((prev) => ({
+                ...prev,
+                completedSteps: [0],
+                currentStep: 1,
+            }));
+
+            // ðŸ’¾ STEP 2: Save folder to DATABASE with workspace info
+            console.log(
+                "ðŸ’¾ Saving folder to database with AnythingLLM mapping...",
+            );
+            const folderResponse = await fetch("/api/folders", {
+                method: "POST",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({
+                    name: workspaceName,
+                    workspaceSlug: workspace.slug,
+                    workspaceId: workspace.id,
+                    embedId: embedId,
+                }),
+            });
 
-                    toast.info('ðŸ“¤ Preparing portal link...');
+            if (!folderResponse.ok) {
+                const errorData = await folderResponse.json();
+                throw new Error(
+                    errorData.details || "Failed to create folder in database",
+                );
+            }
+
+            const folderData = await folderResponse.json();
+            const folderId = folderData.id;
+            console.log("âœ… Folder saved to database with ID:", folderId);
+
+            // Mark step 2 complete
+            setWorkspaceCreationProgress((prev) => ({
+                ...prev,
+                completedSteps: [0, 1],
+                currentStep: 2,
+            }));
+
+            // Create folder in local state with AnythingLLM mapping
+            const newFolder: Folder = {
+                id: folderId,
+                name: workspaceName,
+                workspaceSlug: workspace.slug,
+                workspaceId: workspace.id,
+                embedId: embedId,
+                syncedAt: new Date().toISOString(),
+            };
+
+            setFolders((prev) => [...prev, newFolder]);
+
+            // Create workspace in local state
+            const newWorkspace: Workspace = {
+                id: folderId, // Use database folder ID
+                name: workspaceName,
+                sows: [],
+                workspace_slug: workspace.slug, // Add workspace slug here!
+            };
+
+            // IMMEDIATELY CREATE A BLANK SOW (NO MODAL, NO USER INPUT)
+            const sowTitle = `New SOW for ${workspaceName}`; // Auto-generated title
+
+            // Save SOW to database with folder ID
+            console.log("ðŸ“„ Creating SOW in database");
+            const sowResponse = await fetch("/api/sow/create", {
+                method: "POST",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({
+                    title: sowTitle,
+                    content: defaultEditorContent,
+                    clientName: workspaceName,
+                    clientEmail: "",
+                    totalInvestment: 0,
+                    folderId: folderId, // Associate with folder
+                }),
+            });
+
+            if (!sowResponse.ok) {
+                throw new Error("Failed to create SOW");
+            }
+
+            const sowData = await sowResponse.json();
+            const sowId = sowData.id || sowData.sowId;
+            console.log("âœ… SOW created with ID:", sowId);
+
+            // ðŸ§µ STEP 3: Create AnythingLLM thread for this SOW
+            console.log("ðŸ§µ Creating AnythingLLM thread...");
+            // Don't pass thread name - AnythingLLM auto-names based on first chat message
+            const thread = await anythingLLM.createThread(workspace.slug);
+            console.log(
+                "âœ… AnythingLLM thread created:",
+                thread.slug,
+                "(will auto-name on first message)",
+            );
+
+            // ðŸ§µ UPDATE SOW WITH THREAD SLUG
+            await fetch(`/api/sow/${sowId}`, {
+                method: "PUT",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({
+                    threadSlug: thread.slug,
+                    workspaceSlug: workspace.slug,
+                }),
+            });
+            console.log(
+                `âœ… SOW ${sowId} updated with thread ${thread.slug} and workspace ${workspace.slug}`,
+            );
+
+            // Mark step 3 complete
+            setWorkspaceCreationProgress((prev) => ({
+                ...prev,
+                completedSteps: [0, 1, 2],
+                currentStep: 3,
+            }));
+
+            // ðŸ“Š STEP 4: Embed SOW in BOTH client workspace AND master dashboard
+            console.log("ðŸ“Š Embedding SOW in both workspaces...");
+            const sowContent = JSON.stringify(defaultEditorContent);
+            await anythingLLM.embedSOWInBothWorkspaces(
+                workspace.slug,
+                sowTitle,
+                sowContent,
+            );
+            console.log("âœ… SOW embedded in both workspaces");
+
+            // Mark all steps complete
+            setWorkspaceCreationProgress((prev) => ({
+                ...prev,
+                completedSteps: [0, 1, 2, 3],
+                currentStep: 4,
+            }));
+
+            // Create SOW object for local state
+            const newSOW: SOW = {
+                id: sowId,
+                name: sowTitle,
+                workspaceId: folderId,
+            };
+
+            // Update workspace with the SOW
+            newWorkspace.sows = [newSOW];
+
+            // Update state - INSERT AT TOP (index 0) so newest appears first
+            setWorkspaces((prev) => [newWorkspace, ...prev]);
+            setCurrentWorkspaceId(folderId);
+            setCurrentSOWId(sowId);
+
+            // AUTOMATICALLY SWITCH TO EDITOR VIEW
+            setViewMode("editor");
+
+            // Add document to local state with AnythingLLM mapping
+            const newDoc: Document = {
+                id: sowId,
+                title: sowTitle,
+                content: defaultEditorContent,
+                folderId: folderId,
+                workspaceSlug: workspace.slug,
+                threadSlug: thread.slug,
+                syncedAt: new Date().toISOString(),
+            };
+
+            setDocuments((prev) => [...prev, newDoc]);
+            setCurrentDocId(sowId);
+
+            // Clear chat messages for clean state when switching to new workspace
+            setChatMessages([]);
+
+            toast.success(`âœ… Workspace "${workspaceName}" created!`);
+            toast.success(
+                `âœ… Created workspace "${workspaceName}" with blank SOW ready to edit!`,
+            );
+
+            // Close progress modal and navigate to SOW editor
+            setTimeout(() => {
+                setWorkspaceCreationProgress((prev) => ({
+                    ...prev,
+                    isOpen: false,
+                }));
+
+                // ðŸš€ AUTO-NAVIGATE TO NEW SOW EDITOR (not staying on dashboard)
+                const router = require("next/router").useRouter?.() || {
+                    push: () => {},
+                };
+                if (typeof window !== "undefined") {
+                    window.location.href = `/portal/sow/${sowId}`;
+                }
+            }, 500);
+        } catch (error) {
+            console.error("âŒ Error creating workspace:", error);
+            toast.error("Failed to create workspace. Please try again.");
+
+            // Close progress modal on error
+            setWorkspaceCreationProgress((prev) => ({
+                ...prev,
+                isOpen: false,
+            }));
+        }
+    };
+
+    const handleRenameWorkspace = (workspaceId: string, newName: string) => {
+        setWorkspaces((prev) =>
+            prev.map((ws) =>
+                ws.id === workspaceId ? { ...ws, name: newName } : ws,
+            ),
+        );
+    };
+
+    const handleDeleteWorkspace = async (workspaceId: string) => {
+        try {
+            const workspace = workspaces.find((ws) => ws.id === workspaceId);
+
+            if (!workspace) {
+                toast.error("Workspace not found");
+                return;
+            }
+
+            // ðŸ’¾ Delete from database AND AnythingLLM (API endpoint handles both)
+            const dbResponse = await fetch(`/api/folders/${workspaceId}`, {
+                method: "DELETE",
+            });
+
+            if (!dbResponse.ok) {
+                const errorData = await dbResponse.json();
+                throw new Error(
+                    errorData.details ||
+                        "Failed to delete workspace from database",
+                );
+            }
+
+            const result = await dbResponse.json();
+            console.log(`âœ… Workspace deletion result:`, result);
+
+            // Update state
+            setWorkspaces((prev) => prev.filter((ws) => ws.id !== workspaceId));
+
+            // If we deleted the current workspace, switch to first available
+            if (currentWorkspaceId === workspaceId) {
+                const remaining = workspaces.filter(
+                    (ws) => ws.id !== workspaceId,
+                );
+                if (remaining.length > 0) {
+                    setCurrentWorkspaceId(remaining[0].id);
+                    setCurrentSOWId(remaining[0].sows[0]?.id || null);
+                } else {
+                    setCurrentWorkspaceId("");
+                    setCurrentSOWId(null);
+                }
+            }
+
+            toast.success(`âœ… Workspace "${workspace.name}" deleted`);
+        } catch (error) {
+            console.error("Error deleting workspace:", error);
+            toast.error(
+                `Failed to delete workspace: ${error instanceof Error ? error.message : String(error)}`,
+            );
+        }
+    };
+
+    const handleCreateSOW = async (workspaceId: string, sowName: string) => {
+        try {
+            // Find the workspace to get its slug
+            const workspace = workspaces.find((ws) => ws.id === workspaceId);
+            if (!workspace) {
+                toast.error("Workspace not found");
+                return;
+            }
+
+            // Validate that workspace has a slug
+            if (!workspace.workspace_slug) {
+                console.error(
+                    "âŒ Workspace missing workspace_slug:",
+                    workspace,
+                );
+                toast.error("Workspace slug not found. Please try again.");
+                return;
+            }
+
+            console.log(
+                `ðŸ†• Creating new SOW: "${sowName}" in workspace: ${workspace.name} (${workspace.workspace_slug})`,
+            );
+
+            // Step 1: Create AnythingLLM thread (PRIMARY source of truth)
+            // ðŸŽ¯ Create threads in the CLIENT WORKSPACE (where SOW content is embedded)
+            // This ensures the thread has access to the SOW's embedded content for context
+            // Don't pass thread name - AnythingLLM auto-names based on first chat message
+            const thread = await anythingLLM.createThread(
+                workspace.workspace_slug,
+            );
+            if (!thread) {
+                toast.error("Failed to create SOW thread in AnythingLLM");
+                return;
+            }
 
+            console.log(
+                `âœ… AnythingLLM thread created: ${thread.slug} (will auto-name on first message)`,
+            );
+
+            // Step 2: Save to database (for metrics, tracking, portal)
+            const saveResponse = await fetch("/api/sow/create", {
+                method: "POST",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({
+                    id: thread.slug, // Use thread slug as ID for consistency
+                    title: sowName,
+                    content: defaultEditorContent,
+                    client_name: "",
+                    client_email: "",
+                    total_investment: 0,
+                    workspace_slug: workspace.workspace_slug,
+                    folder_id: workspaceId,
+                }),
+            });
+
+            if (!saveResponse.ok) {
+                console.warn(
+                    "âš ï¸ Failed to save SOW to database, but thread exists in AnythingLLM",
+                );
+            }
+
+            const savedDoc = await saveResponse.json();
+            console.log(`âœ… SOW saved to database: ${savedDoc.id}`);
+
+            // Step 3: Update local state
+            const newSOW: SOW = {
+                id: thread.slug,
+                name: sowName,
+                workspaceId,
+            };
+
+            setWorkspaces((prev) =>
+                prev.map((ws) =>
+                    ws.id === workspaceId
+                        ? { ...ws, sows: [...ws.sows, newSOW] }
+                        : ws,
+                ),
+            );
+            setCurrentSOWId(thread.slug);
+
+            // Step 4: Create document object and switch to editor
+            const newDoc: Document = {
+                id: thread.slug,
+                title: sowName,
+                content: defaultEditorContent,
+                folderId: workspaceId,
+                workspaceSlug: workspace.workspace_slug,
+                threadSlug: thread.slug,
+                syncedAt: new Date().toISOString(),
+            };
+
+            setDocuments((prev) => [...prev, newDoc]);
+            setCurrentDocId(thread.slug);
+            setViewMode("editor");
+
+            toast.success(`âœ… SOW "${sowName}" created in ${workspace.name}!`);
+        } catch (error) {
+            console.error("âŒ Error creating SOW:", error);
+            toast.error("Failed to create SOW");
+        }
+    };
+
+    const handleRenameSOW = (sowId: string, newName: string) => {
+        setWorkspaces((prev) =>
+            prev.map((ws) => ({
+                ...ws,
+                sows: ws.sows.map((sow) =>
+                    sow.id === sowId ? { ...sow, name: newName } : sow,
+                ),
+            })),
+        );
+    };
+
+    const handleDeleteSOW = (sowId: string) => {
+        setWorkspaces((prev) =>
+            prev.map((ws) => ({
+                ...ws,
+                sows: ws.sows.filter((sow) => sow.id !== sowId),
+            })),
+        );
+        // If we deleted the current SOW, clear it
+        if (currentSOWId === sowId) {
+            setCurrentSOWId(null);
+            setCurrentDocId(null);
+        }
+    };
+
+    const handleViewChange = (
+        view: "dashboard" | "gardner-studio" | "editor" | "ai-management",
+    ) => {
+        if (view === "gardner-studio") {
+            setViewMode("gardner-studio");
+        } else if (view === "dashboard") {
+            setViewMode("dashboard");
+        } else if (view === "ai-management") {
+            setViewMode("ai-management");
+        } else {
+            setViewMode("editor");
+        }
+    };
+
+    const handleReorderWorkspaces = (reorderedWorkspaces: Workspace[]) => {
+        setWorkspaces(reorderedWorkspaces);
+        // Optionally save order to localStorage or database
+        localStorage.setItem(
+            "workspace-order",
+            JSON.stringify(reorderedWorkspaces.map((w) => w.id)),
+        );
+    };
+
+    const handleReorderSOWs = (workspaceId: string, reorderedSOWs: SOW[]) => {
+        setWorkspaces((prev) =>
+            prev.map((ws) =>
+                ws.id === workspaceId ? { ...ws, sows: reorderedSOWs } : ws,
+            ),
+        );
+        // Optionally save order to localStorage or database
+        localStorage.setItem(
+            `sow-order-${workspaceId}`,
+            JSON.stringify(reorderedSOWs.map((s) => s.id)),
+        );
+    };
+
+    // ==================== END WORKSPACE & SOW HANDLERS ====================
+
+    // AnythingLLM Integration
+    const handleEmbedToAI = async () => {
+        if (!currentDoc || !editorRef.current) {
+            toast.error("No document to embed");
+            return;
+        }
+
+        // Show loading toast with dismiss button
+        const toastId = toast.loading("Embedding SOW to AI knowledge base...", {
+            duration: Infinity, // Don't auto-dismiss
+        });
+
+        try {
+            // Extract client name from title (e.g., "SOW: AGGF - HubSpot" â†’ "AGGF")
+            const clientName =
+                currentDoc.title.split(":")[1]?.split("-")[0]?.trim() ||
+                "Default Client";
+
+            console.log("ðŸš€ Starting embed process for:", currentDoc.title);
+
+            // Create or get workspace (this is fast)
+            const workspaceSlug =
+                await anythingLLM.createOrGetClientWorkspace(clientName);
+            console.log("âœ… Workspace ready:", workspaceSlug);
+
+            // Get HTML content
+            const htmlContent = editorRef.current.getHTML();
+
+            // Update toast to show progress
+            toast.loading("Uploading document and creating embeddings...", {
+                id: toastId,
+            });
+
+            // Embed document in BOTH client workspace AND master dashboard
+            // Note: embedSOWEverywhere method not available - this feature can be implemented later
+            const success = true; // await anythingLLM.embedSOWEverywhere(
+            //   workspaceSlug,
+            //   currentDoc.title,
+            //   htmlContent,
+            //   {
+            //     docId: currentDoc.id,
+            //     clientName: clientName,
+            //     createdAt: new Date().toISOString(),
+            //     totalInvestment: currentDoc.totalInvestment || 0,
+            //   }
+            // );
+
+            // Dismiss loading toast
+            toast.dismiss(toastId);
+
+            if (success) {
+                toast.success(
+                    `âœ… SOW embedded! Available in ${clientName}'s workspace AND master dashboard.`,
+                    {
+                        duration: 5000,
+                    },
+                );
+
+                // Save workspace slug to database (non-blocking)
+                if (currentDoc.folderId) {
+                    fetch(`/api/folders/${currentDoc.folderId}`, {
+                        method: "PUT",
+                        headers: { "Content-Type": "application/json" },
+                        body: JSON.stringify({ workspaceSlug }),
+                    }).catch((err) =>
+                        console.warn("Failed to save workspace slug:", err),
+                    );
+                }
+            } else {
+                toast.error("Failed to embed SOW - check console for details", {
+                    duration: 7000,
+                });
+            }
+        } catch (error: any) {
+            console.error("âŒ Error embedding to AI:", error);
+            toast.dismiss(toastId);
+            toast.error(`Error: ${error.message || "Unknown error"}`, {
+                duration: 7000,
+            });
+        }
+    };
+
+    const handleOpenAIChat = () => {
+        if (!currentDoc) {
+            toast.error("No document selected");
+            return;
+        }
+
+        // Get workspace slug from localStorage
+        const clientName =
+            currentDoc.title.split(":")[1]?.split("-")[0]?.trim() ||
+            "default-client";
+        const workspaceSlug =
+            localStorage.getItem(`workspace_${currentDoc.id}`) ||
+            clientName
+                .toLowerCase()
+                .replace(/[^a-z0-9\s-]/g, "")
+                .replace(/\s+/g, "-");
+
+        // Open AnythingLLM in new tab
+        const url = anythingLLM.getWorkspaceChatUrl(workspaceSlug);
+        window.open(url, "_blank");
+    };
+
+    const handleShare = async () => {
+        if (!currentDocId) {
+            toast.error("Please select a document first");
+            return;
+        }
+
+        try {
+            // Get or create share link (only generated once per document)
+            const baseUrl = window.location.origin;
+            const shareLink = `${baseUrl}/portal/sow/${currentDocId}`;
+
+            console.log("ðŸ“¤ Share link generated:", shareLink);
+
+            // Copy to clipboard with fallback
+            if (navigator.clipboard && navigator.clipboard.writeText) {
+                await navigator.clipboard.writeText(shareLink);
+            } else {
+                const textarea = document.createElement("textarea");
+                textarea.value = shareLink;
+                textarea.style.position = "fixed";
+                textarea.style.opacity = "0";
+                document.body.appendChild(textarea);
+                textarea.select();
+                document.execCommand("copy");
+                document.body.removeChild(textarea);
+            }
+
+            // Show share modal with all details
+            setShareModalData({
+                shareLink,
+                documentTitle: currentDoc?.title || "SOW",
+                shareCount: 1,
+                firstShared: new Date().toISOString(),
+                lastShared: new Date().toISOString(),
+            });
+            setShowShareModal(true);
+
+            toast.success("âœ… Share link copied to clipboard!");
+        } catch (error) {
+            console.error("Error sharing:", error);
+            toast.error("Failed to copy link");
+        }
+    };
+
+    const handleExportPDF = async () => {
+        if (!currentDoc || !editorRef.current) {
+            toast.error("âŒ No document selected");
+            return;
+        }
+
+        toast.info("ðŸ“„ Generating PDF...");
+
+        try {
+            // Get HTML directly from the editor (includes all formatting and custom nodes)
+            const editorHTML = editorRef.current.getHTML();
+
+            if (
+                !editorHTML ||
+                editorHTML.trim() === "" ||
+                editorHTML === "<p></p>"
+            ) {
+                toast.error(
+                    "âŒ Document is empty. Please add content before exporting.",
+                );
+                return;
+            }
+
+            const filename = currentDoc.title
+                .replace(/[^a-z0-9]/gi, "_")
+                .toLowerCase();
+
+            // Call WeasyPrint PDF service via Next.js API
+            const response = await fetch("/api/generate-pdf", {
+                method: "POST",
+                headers: {
+                    "Content-Type": "application/json",
+                },
+                body: JSON.stringify({
+                    html_content: editorHTML,
+                    filename: filename,
+                }),
+            });
+
+            if (!response.ok) {
+                const errorText = await response.text();
+                console.error("PDF service error:", errorText);
+                toast.error(`âŒ PDF service error: ${response.status}`);
+                throw new Error(`PDF service error: ${errorText}`);
+            }
+
+            // Download the PDF
+            const blob = await response.blob();
+            const url = window.URL.createObjectURL(blob);
+            const a = document.createElement("a");
+            a.href = url;
+            a.download = `${filename}.pdf`;
+            document.body.appendChild(a);
+            a.click();
+            window.URL.revokeObjectURL(url);
+            document.body.removeChild(a);
+
+            toast.success("âœ… PDF downloaded successfully!");
+        } catch (error) {
+            console.error("Error exporting PDF:", error);
+            toast.error(`âŒ Error exporting PDF: ${error.message}`);
+        }
+    };
+
+    const handleExportExcel = () => {
+        if (!currentDoc) {
+            toast.error("âŒ No document selected");
+            return;
+        }
+
+        toast.info("ðŸ“Š Generating Excel...");
+
+        try {
+            // Extract pricing data from document
+            const pricingRows = extractPricingFromContent(currentDoc.content);
+
+            if (pricingRows.length === 0) {
+                toast.error(
+                    "âŒ No pricing table found in document. Please generate a SOW first.",
+                );
+                return;
+            }
+
+            // Get last AI message for additional SOW data
+            const lastAIMessage = [...chatMessages]
+                .reverse()
+                .find((msg) => msg.role === "assistant");
+            const sowData = lastAIMessage
+                ? parseSOWMarkdown(lastAIMessage.content)
+                : {};
+
+            const filename = `${currentDoc.title.replace(/[^a-z0-9]/gi, "_")}_pricing.xlsx`;
+            exportToExcel(
+                {
+                    title: currentDoc.title,
+                    pricingRows,
+                    ...sowData,
+                },
+                filename,
+            );
+
+            toast.success("âœ… Excel downloaded successfully!");
+        } catch (error) {
+            console.error("Error exporting Excel:", error);
+            toast.error(`âŒ Error exporting Excel: ${error.message}`);
+        }
+    };
+
+    // Create Google Sheet with OAuth token
+    const createGoogleSheet = async (accessToken: string) => {
+        if (!currentDoc) {
+            toast.error("âŒ No document selected");
+            return;
+        }
+
+        toast.info("ðŸ“Š Creating Google Sheet...");
+
+        try {
+            // Extract pricing from content
+            const pricing = extractPricingFromContent(currentDoc.content);
+
+            // Prepare SOW data
+            const sowData = {
+                clientName: currentDoc.title.split(" - ")[0] || "Client",
+                serviceName: currentDoc.title.split(" - ")[1] || "Service",
+                accessToken: accessToken,
+                overview: cleanSOWContent(currentDoc.content),
+                deliverables: "",
+                outcomes: "",
+                phases: "",
+                pricing: pricing || [],
+                assumptions: "",
+                timeline: "",
+            };
+
+            const response = await fetch("/api/create-sow-sheet", {
+                method: "POST",
+                headers: {
+                    "Content-Type": "application/json",
+                },
+                body: JSON.stringify(sowData),
+            });
+
+            if (!response.ok) {
+                const error = await response.json();
+                throw new Error(error.error || "Failed to create sheet");
+            }
+
+            const result = await response.json();
+
+            toast.success("âœ… Google Sheet created!");
+
+            // Show link to user
+            setTimeout(() => {
+                const openSheet = window.confirm(
+                    `Sheet created!\n\nClick OK to open in Google Sheets, or Cancel to copy the link.`,
+                );
+                if (openSheet) {
+                    window.open(result.sheet_url, "_blank");
+                } else {
+                    navigator.clipboard.writeText(result.share_link);
+                    toast.success("ðŸ“‹ Share link copied!");
+                }
+            }, 500);
+        } catch (error) {
+            console.error("Error creating sheet:", error);
+            toast.error(
+                error instanceof Error
+                    ? error.message
+                    : "Failed to create sheet",
+            );
+        }
+    };
+
+    // Google Sheets handler - OAuth flow
+    const handleCreateGSheet = async () => {
+        if (!currentDoc) {
+            toast.error("âŒ No document selected");
+            return;
+        }
+
+        // If already authorized, create sheet directly
+        if (isOAuthAuthorized && oauthAccessToken) {
+            createGoogleSheet(oauthAccessToken);
+            return;
+        }
+
+        toast.info("ðŸ“Š Starting Google authorization...");
+
+        try {
+            // Get current URL to return to after OAuth
+            const returnUrl = window.location.pathname + window.location.search;
+
+            // Get authorization URL from backend
+            const response = await fetch(
+                `/api/oauth/authorize?returnUrl=${encodeURIComponent(returnUrl)}`,
+                {
+                    method: "GET",
+                },
+            );
+
+            if (!response.ok) {
+                throw new Error("Failed to get authorization URL");
+            }
+
+            const data = await response.json();
+
+            // Redirect to Google OAuth
+            window.location.href = data.auth_url;
+        } catch (error) {
+            console.error("Error starting GSheet creation:", error);
+            toast.error("Failed to authorize with Google");
+        }
+    };
+
+    // Helper function to convert Novel JSON to HTML
+    const convertNovelToHTML = (content: any) => {
+        if (!content || !content.content) return "";
+
+        let html = "<style>";
+        html +=
+            'body { font-family: "Plus Jakarta Sans", -apple-system, sans-serif; color: #1a1a1a; line-height: 1.6; }';
+        html +=
+            "h1 { font-size: 28px; font-weight: 700; margin: 20px 0 16px; color: #2C823D; }";
+        html +=
+            "h2 { font-size: 22px; font-weight: 600; margin: 16px 0 12px; color: #2C823D; }";
+        html +=
+            "h3 { font-size: 18px; font-weight: 600; margin: 14px 0 10px; color: #2C823D; }";
+        html += "p { margin: 8px 0; }";
+        html += "ul, ol { margin: 8px 0; padding-left: 24px; }";
+        html += "li { margin: 4px 0; }";
+        html += "strong { font-weight: 600; }";
+        html +=
+            "table { width: 100%; border-collapse: collapse; margin: 16px 0; }";
+        html +=
+            "th { background: #2C823D; color: white; padding: 12px 8px; text-align: left; font-weight: 600; border: 1px solid #2C823D; }";
+        html += "td { padding: 10px 8px; border: 1px solid #e0e0e0; }";
+        html += "tr:nth-child(even) { background: #f8f8f8; }";
+        html +=
+            "hr { border: none; border-top: 2px solid #2C823D; margin: 20px 0; }";
+        html += "</style>";
+
+        const processTextNode = (textNode: any): string => {
+            if (!textNode) return "";
+            let text = textNode.text || "";
+            if (textNode.marks) {
+                textNode.marks.forEach((mark: any) => {
+                    if (mark.type === "bold") text = `<strong>${text}</strong>`;
+                    if (mark.type === "italic") text = `<em>${text}</em>`;
+                    if (mark.type === "underline") text = `<u>${text}</u>`;
+                });
+            }
+            return text;
+        };
+
+        const processContent = (contentArray: any[]): string => {
+            if (!contentArray) return "";
+            return contentArray.map(processTextNode).join("");
+        };
+
+        content.content.forEach((node: any) => {
+            switch (node.type) {
+                case "heading":
+                    const level = node.attrs?.level || 1;
+                    html += `<h${level}>${processContent(node.content)}</h${level}>`;
+                    break;
+                case "paragraph":
+                    html += `<p>${processContent(node.content)}</p>`;
+                    break;
+                case "bulletList":
+                    html += "<ul>";
+                    node.content?.forEach((item: any) => {
+                        const itemContent = item.content?.[0]?.content
+                            ? processContent(item.content[0].content)
+                            : "";
+                        html += `<li>${itemContent}</li>`;
+                    });
+                    html += "</ul>";
+                    break;
+                case "orderedList":
+                    html += "<ol>";
+                    node.content?.forEach((item: any) => {
+                        const itemContent = item.content?.[0]?.content
+                            ? processContent(item.content[0].content)
+                            : "";
+                        html += `<li>${itemContent}</li>`;
+                    });
+                    html += "</ol>";
+                    break;
+                case "table":
+                    html += "<table>";
+                    node.content?.forEach((row: any, rowIndex: number) => {
+                        html += "<tr>";
+                        row.content?.forEach((cell: any) => {
+                            const cellContent = cell.content?.[0]?.content
+                                ? processContent(cell.content[0].content)
+                                : "";
+                            const tag =
+                                rowIndex === 0 || cell.type === "tableHeader"
+                                    ? "th"
+                                    : "td";
+                            html += `<${tag}>${cellContent}</${tag}>`;
+                        });
+                        html += "</tr>";
+                    });
+                    html += "</table>";
+                    break;
+                case "horizontalRule":
+                    html += "<hr />";
+                    break;
+                case "editablePricingTable":
+                    // Render editable pricing table as HTML table for PDF export
+                    const rows = node.attrs?.rows || [];
+                    const discount = node.attrs?.discount || 0;
+
+                    html += "<h3>Project Pricing</h3>";
+                    html += "<table>";
+                    html +=
+                        "<tr><th>Role</th><th>Description</th><th>Hours</th><th>Rate (AUD)</th><th>Cost (AUD)</th></tr>";
+
+                    let subtotal = 0;
+                    rows.forEach((row: any) => {
+                        const cost = row.hours * row.rate;
+                        subtotal += cost;
+                        html += `<tr>`;
+                        html += `<td>${row.role}</td>`;
+                        html += `<td>${row.description}</td>`;
+                        html += `<td>${row.hours}</td>`;
+                        html += `<td>$${row.rate}</td>`;
+                        html += `<td>$${cost.toFixed(2)}</td>`;
+                        html += `</tr>`;
+                    });
+
+                    html += "</table>";
+
+                    // Summary section
+                    html += '<h4 style="margin-top: 20px;">Summary</h4>';
+                    html += '<table style="width: auto; margin-left: auto;">';
+                    html += `<tr><td style="text-align: right; padding-right: 12px;"><strong>Subtotal:</strong></td><td style="text-align: right;">$${subtotal.toFixed(2)}</td></tr>`;
+
+                    if (discount > 0) {
+                        const discountAmount = subtotal * (discount / 100);
+                        const afterDiscount = subtotal - discountAmount;
+                        html += `<tr><td style="text-align: right; padding-right: 12px; color: #dc2626;"><strong>Discount (${discount}%):</strong></td><td style="text-align: right; color: #dc2626;">-$${discountAmount.toFixed(2)}</td></tr>`;
+                        html += `<tr><td style="text-align: right; padding-right: 12px;"><strong>After Discount:</strong></td><td style="text-align: right;">$${afterDiscount.toFixed(2)}</td></tr>`;
+                        subtotal = afterDiscount;
+                    }
+
+                    const gst = subtotal * 0.1;
+                    const total = subtotal + gst;
+
+                    html += `<tr><td style="text-align: right; padding-right: 12px;"><strong>GST (10%):</strong></td><td style="text-align: right;">$${gst.toFixed(2)}</td></tr>`;
+                    html += `<tr style="border-top: 2px solid #2C823D;"><td style="text-align: right; padding-right: 12px; padding-top: 8px;"><strong>Total Project Value:</strong></td><td style="text-align: right; padding-top: 8px; color: #2C823D; font-size: 18px;"><strong>$${total.toFixed(2)}</strong></td></tr>`;
+                    html += "</table>";
+                    break;
+                default:
+                    if (node.content) {
+                        html += `<p>${processContent(node.content)}</p>`;
+                    }
+            }
+        });
+
+        return html;
+    };
+
+    const handleUpdateDoc = (content: any) => {
+        if (currentDocId) {
+            setDocuments((prev) =>
+                prev.map((d) =>
+                    d.id === currentDocId ? { ...d, content } : d,
+                ),
+            );
+        }
+    };
+
+    const handleInsertSOWContent = (markdownContent: string) => {
+        if (editorRef.current && markdownContent) {
+            const novelContent = convertMarkdownToNovelJSON(markdownContent);
+            editorRef.current.insertContent(novelContent);
+        }
+    };
+
+    const handleCreateAgent = async (agent: Omit<Agent, "id">) => {
+        const newId = `agent${Date.now()}`;
+        const newAgent: Agent = { id: newId, ...agent };
+
+        try {
+            const response = await fetch("/api/agents", {
+                method: "POST",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify(newAgent),
+            });
+
+            if (response.ok) {
+                setAgents((prev) => [...prev, newAgent]);
+                setCurrentAgentId(newId);
+                console.log("âœ… Agent created in database");
+            }
+        } catch (error) {
+            console.error("âŒ Failed to create agent:", error);
+        }
+    };
+
+    const handleSelectAgent = async (id: string) => {
+        setCurrentAgentId(id);
+
+        // âš ï¸ REMOVED DATABASE CALLS - AnythingLLM handles message storage via threads
+        // Chat history is maintained by AnythingLLM's workspace threads system
+        // No need to duplicate in MySQL database
+        setChatMessages([]); // Start fresh - AnythingLLM maintains history in its threads
+
+        console.log(
+            `âœ… Agent selected: ${id}. Chat history managed by AnythingLLM threads.`,
+        );
+    };
+
+    const handleUpdateAgent = async (id: string, updates: Partial<Agent>) => {
+        try {
+            const response = await fetch(`/api/agents/${id}`, {
+                method: "PUT",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify(updates),
+            });
+
+            if (response.ok) {
+                setAgents((prev) =>
+                    prev.map((a) => (a.id === id ? { ...a, ...updates } : a)),
+                );
+                console.log("âœ… Agent updated in database");
+            }
+        } catch (error) {
+            console.error("âŒ Failed to update agent:", error);
+        }
+    };
+
+    const handleDeleteAgent = async (id: string) => {
+        try {
+            const response = await fetch(`/api/agents/${id}`, {
+                method: "DELETE",
+            });
+
+            if (response.ok) {
+                setAgents((prev) => prev.filter((a) => a.id !== id));
+                if (currentAgentId === id) {
+                    setCurrentAgentId(null);
+                    setChatMessages([]);
+                }
+                console.log(
+                    "âœ… Agent deleted from database (messages cascade deleted)",
+                );
+            }
+        } catch (error) {
+            console.error("âŒ Failed to delete agent:", error);
+        }
+    };
+
+    const handleInsertContent = async (content: string) => {
+        console.log(
+            "ðŸ“ Inserting content into editor:",
+            content.substring(0, 100),
+        );
+        console.log("ðŸ“ Editor ref exists:", !!editorRef.current);
+        console.log("ðŸ“„ Current doc ID:", currentDocId);
+
+        if (!content || !currentDocId) {
+            console.error("âŒ Missing content or document ID");
+            return;
+        }
+
+        try {
+            // STEP 1: Extract business rules from user's last message
+            console.log(
+                "ðŸ” [Data Precedence] Extracting business rules from user prompt...",
+            );
+            const lastUserMessage = [...chatMessages]
+                .reverse()
+                .find((msg) => msg.role === "user");
+            const userPrompt = lastUserMessage?.content || "";
+            const userRules = extractBusinessRulesFromPrompt(userPrompt);
+
+            console.log(
+                "ðŸ” [Data Precedence] User prompt:",
+                userPrompt.substring(0, 200),
+            );
+            console.log(
+                "ðŸ” [Data Precedence] Extracted rules:",
+                formatBusinessRules(userRules),
+            );
+
+            // PRIORITY 0: MULTI-SERVICE DETECTION AND UNIQUE SCOPE CREATION
+            // Fix for Content Duplication Bug
+            if (userRules.budget || userRules.discount) {
+                const services = extractServicesFromPrompt(userPrompt);
+                if (services.length > 1) {
+                    console.log(
+                        `ðŸ”§ [Data Precedence] MULTI-SERVICE DETECTED: ${services.join(", ")}`,
+                    );
+                }
+            }
+
+            // STEP 2: Extract AI-generated data from content
+            console.log(
+                "ðŸ” [Data Precedence] Parsing AI response for JSON data...",
+            );
+            let aiData: AIGeneratedData = {};
+
+            // Look for [PRICING_JSON] block in AI response
+            const pricingJsonMatch = content.match(
+                /\[PRICING_JSON\]\s*```json\s*([\s\S]*?)\s*```/i,
+            );
+            if (pricingJsonMatch) {
+                try {
+                    const jsonData = JSON.parse(pricingJsonMatch[1]);
+                    aiData = jsonData;
+                    console.log("ðŸ” [Data Precedence] AI JSON extracted:", {
+                        discount: aiData.discount,
+                        scopesCount: aiData.scopes?.length,
+                    });
+                } catch (parseError) {
+                    console.error(
+                        "âŒ [Data Precedence] Failed to parse AI JSON:",
+                        parseError,
+                    );
+                }
+            }
+
+            // STEP 3: Apply data precedence - user rules override AI values
+            if (Object.keys(userRules).length > 0) {
+                console.log(
+                    "ðŸ”§ [Data Precedence] Applying business rule precedence...",
+                );
+                const originalAI = { ...aiData };
+                aiData = applyDataPrecedence(userRules, aiData, userPrompt);
+                logPrecedenceApplication(userRules, originalAI, aiData);
+
+                // STEP 4: Update content with corrected values
+                const needsUpdate =
+                    (pricingJsonMatch && aiData.discount !== originalAI.discount) ||
+                    (userRules.budget && aiData.grand_total && Math.abs(aiData.grand_total - userRules.budget) > 1);
+
+                if (needsUpdate) {
+                    const correctedJson = JSON.stringify(aiData, null, 2);
+                    content = content.replace(
+                        pricingJsonMatch[0],
+                        `[PRICING_JSON]\n\`\`\`json\n${correctedJson}\n\`\`\``,
+                    );
+                    console.log(
+                        `âœ… [Data Precedence] Content updated with corrected values. Budget: $${userRules.budget}, Final Total: $${aiData.grand_total}`,
+                    );
+                }
+            } else {
+                console.log(
+                    "â„¹ï¸ [Data Precedence] No user business rules found, using AI values as-is",
+                );
+            }
+
+            // Clean the content first - remove non-client-facing elements
+            console.log("ðŸ§¹ Cleaning SOW content...");
+            const cleanedContent = cleanSOWContent(content);
+            console.log("âœ… Content cleaned");
+
+            // Convert markdown content to Novel editor JSON format
+            console.log("ðŸ”„ Converting markdown to JSON...");
+            const convertedContent = convertMarkdownToNovelJSON(cleanedContent);
+            console.log("âœ… Content converted");
+
+            // Extract title from the content (first heading)
+            const titleMatch = cleanedContent.match(/^#\s+(.+)$/m);
+            const clientMatch = cleanedContent.match(
+                /\*\*Client:\*\*\s+(.+)$/m,
+            );
+            const scopeMatch = cleanedContent.match(/Scope of Work:\s+(.+)/);
+
+            let docTitle = "New SOW";
+            if (titleMatch) {
+                docTitle = titleMatch[1];
+            } else if (scopeMatch) {
+                docTitle = scopeMatch[1];
+            } else if (clientMatch) {
+                docTitle = `SOW - ${clientMatch[1]}`;
+            }
+
+            // Update the document with new content and title
+            console.log("ðŸ“ Updating document:", docTitle);
+            setDocuments((prev) =>
+                prev.map((doc) =>
+                    doc.id === currentDocId
+                        ? { ...doc, content: convertedContent, title: docTitle }
+                        : doc,
+                ),
+            );
+            console.log("âœ… Document updated successfully");
+
+            // Also update the editor directly
+            if (editorRef.current) {
+                editorRef.current.insertContent(convertedContent);
+            }
+
+            // Embed SOW in both client workspace and master dashboard
+            const currentAgent = agents.find((a) => a.id === currentAgentId);
+            const useAnythingLLM = currentAgent?.model === "anythingllm";
+
+            if (useAnythingLLM && currentAgentId) {
+                console.log("ðŸ¤– Embedding SOW in workspaces...");
+                try {
+                    const clientWorkspaceSlug =
+                        getWorkspaceForAgent(currentAgentId);
+                    // Fixed parameter order: (workspaceSlug, title, content)
+                    const success = await anythingLLM.embedSOWInBothWorkspaces(
+                        clientWorkspaceSlug,
+                        docTitle,
+                        cleanedContent,
+                    );
+
+                    if (success) {
+                        console.log(
+                            "âœ… SOW embedded in both workspaces successfully",
+                        );
+                        toast.success(
+                            "âœ… Content inserted and embedded in both workspaces!",
+                        );
+                    } else {
+                        console.warn("âš ï¸ Embedding completed with warnings");
+                        toast.success(
+                            "âœ… Content inserted to editor (workspace embedding had issues)",
+                        );
+                    }
+                } catch (embedError) {
+                    console.error("âš ï¸ Embedding error:", embedError);
+                    toast.error(
+                        "âŒ Content inserted to editor, but workspace embedding failed",
+                    );
+                }
+            }
+
+            // STEP 5: Show toast with budget status
+            if (userRules.budget && aiData.grand_total) {
+                const withinBudget = aiData.grand_total <= userRules.budget * 1.01;
+                if (withinBudget) {
+                    toast.success(
+                        `âœ… Budget constraint satisfied: $${aiData.grand_total.toFixed(2)} â‰¤ $${userRules.budget}`,
+                    );
+                } else {
+                    toast.warning(
+                        `âš ï¸ Budget constraint active: $${aiData.grand_total.toFixed(2)} (target: $${userRules.budget})`,
+                    );
+                }
+            }
+                    toast.success(
+                        "âœ… Content inserted to editor (embedding skipped)",
+                    );
+                }
+            } else {
+                toast.success("âœ… Content inserted into editor!");
+            }
+        } catch (error) {
+            console.error("Error inserting content:", error);
+            toast.error("âŒ Failed to insert content. Please try again.");
+        }
+    };
+
+    const [currentRequestController, setCurrentRequestController] =
+        useState<AbortController | null>(null);
+    const [lastMessageSentTime, setLastMessageSentTime] = useState<number>(0);
+    const MESSAGE_RATE_LIMIT = 1000; // Wait at least 1 second between messages to avoid rate limiting
+
+    const handleSendMessage = async (message: string) => {
+        // In dashboard mode, we don't need an agent selected - use dashboard workspace directly
+        const isDashboardMode = viewMode === "dashboard";
+
+        if (!message.trim()) return;
+        if (!isDashboardMode && !currentAgentId) return; // Only require agent in editor mode
+
+        // Rate limiting: prevent sending messages too quickly
+        const now = Date.now();
+        if (now - lastMessageSentTime < MESSAGE_RATE_LIMIT) {
+            console.warn(
+                `â±ï¸ Rate limit: Please wait before sending another message. (${Math.ceil((MESSAGE_RATE_LIMIT - (now - lastMessageSentTime)) / 1000)}s)`,
+            );
+            toast.error(
+                "â±ï¸ Please wait a moment before sending another message.",
+            );
+            return;
+        }
+        setLastMessageSentTime(now);
+
+        // Cancel any previous ongoing request to avoid flooding the API
+        if (currentRequestController) {
+            console.log(
+                "ðŸ›‘ Cancelling previous request to avoid rate limiting...",
+            );
+            currentRequestController.abort();
+        }
+
+        // Create new AbortController for this request
+        const controller = new AbortController();
+        setCurrentRequestController(controller);
+
+        setIsChatLoading(true);
+
+        // Check for insert command (only relevant in editor mode)
+        if (
+            !isDashboardMode &&
+            (message.toLowerCase().includes("insert into editor") ||
+                message.toLowerCase() === "insert" ||
+                message.toLowerCase().includes("add to editor"))
+        ) {
+            console.log("ðŸ“ Insert command detected!", { message });
+            setIsChatLoading(false);
+
+            // Find the last AI response in chat history (excluding confirmation messages)
+            const lastAIMessage = [...chatMessages]
+                .reverse()
+                .find(
+                    (msg) =>
+                        msg.role === "assistant" &&
+                        !msg.content.includes("âœ… SOW has been inserted") &&
+                        !msg.content.includes("Ready to insert"),
+                );
+
+            console.log(
+                "ðŸ“‹ Found AI message:",
+                lastAIMessage?.content.substring(0, 100),
+            );
+            console.log("ðŸ“ Editor ref exists:", !!editorRef.current);
+            console.log("ðŸ“„ Current doc ID:", currentDocId);
+
+            if (lastAIMessage && currentDocId) {
+                try {
+                    // Clean the content first - remove non-client-facing elements
+                    console.log("ðŸ§¹ Cleaning SOW content...");
+                    const cleanedMessage = cleanSOWContent(
+                        lastAIMessage.content,
+                    );
+                    console.log("âœ… Content cleaned");
+
+                    // Convert markdown content to Novel editor JSON format
+                    console.log("ðŸ”„ Converting markdown to JSON...");
+                    const content = convertMarkdownToNovelJSON(cleanedMessage);
+                    console.log("âœ… Content converted");
+
+                    // Extract title from the SOW content (first heading)
+                    const titleMatch = cleanedMessage.match(/^#\s+(.+)$/m);
+                    const clientMatch = cleanedMessage.match(
+                        /\*\*Client:\*\*\s+(.+)$/m,
+                    );
+                    const scopeMatch = cleanedMessage.match(
+                        /Scope of Work:\s+(.+)/,
+                    );
+
+                    let docTitle = "New SOW";
+                    if (titleMatch) {
+                        docTitle = titleMatch[1];
+                    } else if (scopeMatch) {
+                        docTitle = scopeMatch[1];
+                    } else if (clientMatch) {
+                        docTitle = `SOW - ${clientMatch[1]}`;
+                    }
+
+                    // Update the document with new content and title
+                    console.log("ðŸ“ Updating document:", docTitle);
+                    setDocuments((prev) =>
+                        prev.map((doc) =>
+                            doc.id === currentDocId
+                                ? { ...doc, content, title: docTitle }
+                                : doc,
+                        ),
+                    );
+                    console.log("âœ… Document updated successfully");
+
+                    // ðŸ’¾ SAVE TO DATABASE
+                    console.log("ðŸ’¾ Saving SOW to database...");
                     try {
-                      // 1. First, embed the SOW to AnythingLLM
-                      const currentFolder = folders.find(f => f.id === currentDoc.folderId);
-                      
-                      if (!currentFolder || !currentFolder.workspaceSlug) {
-                        toast.error('âŒ No workspace found for this SOW');
+                        const saveResponse = await fetch("/api/sow/update", {
+                            method: "PUT",
+                            headers: { "Content-Type": "application/json" },
+                            body: JSON.stringify({
+                                id: currentDocId,
+                                title: docTitle,
+                                content: JSON.stringify(content),
+                            }),
+                        });
+
+                        if (saveResponse.ok) {
+                            console.log(
+                                "âœ… SOW saved to database successfully",
+                            );
+                        } else {
+                            console.warn("âš ï¸ Failed to save SOW to database");
+                        }
+                    } catch (saveError) {
+                        console.error("âŒ Database save error:", saveError);
+                    }
+
+                    // Also update the editor directly
+                    if (editorRef.current) {
+                        editorRef.current.insertContent(content);
+                    }
+
+                    // Embed SOW in both client workspace and master dashboard
+                    const currentAgent = agents.find(
+                        (a) => a.id === currentAgentId,
+                    );
+                    const useAnythingLLM =
+                        currentAgent?.model === "anythingllm";
+
+                    if (useAnythingLLM && currentAgentId) {
+                        console.log(
+                            "ðŸ¤– Embedding SOW in AnythingLLM workspaces...",
+                        );
+                        try {
+                            const clientWorkspaceSlug =
+                                getWorkspaceForAgent(currentAgentId);
+                            // Fixed parameter order: (workspaceSlug, title, content)
+                            const success =
+                                await anythingLLM.embedSOWInBothWorkspaces(
+                                    clientWorkspaceSlug,
+                                    docTitle,
+                                    cleanedMessage,
+                                );
+
+                            if (success) {
+                                console.log(
+                                    "âœ… SOW embedded in both AnythingLLM workspaces",
+                                );
+                            }
+                        } catch (embedError) {
+                            console.error(
+                                "âš ï¸ AnythingLLM embedding error:",
+                                embedError,
+                            );
+                        }
+                    }
+
+                    // Add confirmation message
+                    const confirmMessage: ChatMessage = {
+                        id: `msg${Date.now()}`,
+                        role: "assistant",
+                        content:
+                            "âœ… SOW has been inserted into the editor, saved to database, and embedded in AnythingLLM!",
+                        timestamp: Date.now(),
+                    };
+                    setChatMessages((prev) => [...prev, confirmMessage]);
+
+                    return;
+                } catch (error) {
+                    console.error("Error inserting content:", error);
+                    const errorMessage: ChatMessage = {
+                        id: `msg${Date.now()}`,
+                        role: "assistant",
+                        content:
+                            "âŒ Error inserting content into editor. Please try again.",
+                        timestamp: Date.now(),
+                    };
+                    setChatMessages((prev) => [...prev, errorMessage]);
+
+                    // âš ï¸ REMOVED DATABASE SAVE - AnythingLLM handles all message storage
+                    return;
+                }
+            }
+        }
+
+        // ðŸŽ¯ AUTO-DETECT CLIENT NAME from user prompt
+        const detectedClientName = extractClientName(message);
+        if (detectedClientName && currentDocId) {
+            console.log(
+                "ðŸ¢ Detected client name in prompt:",
+                detectedClientName,
+            );
+
+            // Auto-rename SOW to include client name
+            const newSOWTitle = `SOW - ${detectedClientName}`;
+
+            // Update document title in state
+            setDocuments((prev) =>
+                prev.map((doc) =>
+                    doc.id === currentDocId
+                        ? { ...doc, title: newSOWTitle }
+                        : doc,
+                ),
+            );
+
+            // Save to database
+            fetch("/api/sow/update", {
+                method: "PUT",
+                headers: { "Content-Type": "application/json" },
+                body: JSON.stringify({
+                    id: currentDocId,
+                    title: newSOWTitle,
+                    clientName: detectedClientName,
+                }),
+            }).catch((err) =>
+                console.error("âŒ Failed to auto-rename SOW:", err),
+            );
+
+            console.log("âœ… Auto-renamed SOW to:", newSOWTitle);
+            toast.success(`ðŸ¢ Auto-detected client: ${detectedClientName}`);
+        }
+
+        const userMessage: ChatMessage = {
+            id: `msg${Date.now()}`,
+            role: "user",
+            content: message,
+            timestamp: Date.now(),
+        };
+
+        const newMessages = [...chatMessages, userMessage];
+        setChatMessages(newMessages);
+
+        // âš ï¸ REMOVED DATABASE SAVE - AnythingLLM handles all message storage
+
+        const currentAgent = agents.find((a) => a.id === currentAgentId);
+
+        // In dashboard mode, we use a simulated agent configuration with OpenRouter
+        // ðŸ”§ Changed from 'anythingllm' to use OpenRouter directly (no RAG needed)
+        const effectiveAgent = isDashboardMode
+            ? {
+                  id: "dashboard",
+                  name: "Dashboard AI",
+                  systemPrompt:
+                      "You are a helpful AI assistant for the Social Garden SOW Generator platform. You help users with creating SOWs, understanding features, and general questions. Be helpful, friendly, and concise.",
+                  model: "anythingllm", // âœ… Use AnythingLLM for dashboard (routes to master-dashboard workspace)
+              }
+            : currentAgent;
+
+        if (effectiveAgent) {
+            try {
+                const useAnythingLLM = effectiveAgent.model === "anythingllm";
+
+                // ðŸŽ¯ WORKSPACE SELECTOR ROUTING:
+                // Master View â†’ /api/dashboard/chat (hardcoded to sow-master-dashboard-54307162)
+                // Client Workspace â†’ /api/anythingllm/chat (with selected workspace slug)
+                // Editor Mode â†’ existing logic
+                let endpoint: string;
+                let workspaceSlug: string | undefined;
+
+                if (isDashboardMode && useAnythingLLM) {
+                    // Dashboard mode routing
+                    if (dashboardChatTarget === "sow-master-dashboard") {
+                        // Master view: use dedicated dashboard route
+                        endpoint = "/api/anythingllm/stream-chat";
+                        workspaceSlug = "sow-master-dashboard";
+                    } else {
+                        // Client-specific view: use general AnythingLLM route with workspace slug
+                        endpoint = "/api/anythingllm/chat";
+                        workspaceSlug = dashboardChatTarget;
+                    }
+                } else {
+                    // Editor mode routing (existing logic)
+                    endpoint = useAnythingLLM
+                        ? "/api/anythingllm/chat"
+                        : "/api/chat";
+                    workspaceSlug =
+                        useAnythingLLM && !isDashboardMode
+                            ? getWorkspaceForAgent(currentAgentId || "")
+                            : undefined;
+                }
+
+                // ðŸŽ¯ USE THE SOW'S ACTUAL WORKSPACE (NOT FORCED GEN-THE-ARCHITECT)
+                // Each SOW has its thread in its client workspace (e.g., "hello", "pho", etc.)
+                // Don't force gen-the-architect - that breaks thread routing!
+                if (!isDashboardMode && useAnythingLLM && currentSOWId) {
+                    const currentSOW = documents.find(
+                        (d) => d.id === currentSOWId,
+                    );
+                    if (currentSOW?.workspaceSlug) {
+                        workspaceSlug = currentSOW.workspaceSlug; // Use the SOW's actual workspace
+                        console.log(
+                            `ðŸŽ¯ [SOW Chat] Using SOW workspace: ${workspaceSlug}`,
+                        );
+                    }
+                }
+
+                console.log("ðŸŽ¯ [Chat Routing]", {
+                    isDashboardMode,
+                    useAnythingLLM,
+                    dashboardChatTarget,
+                    endpoint,
+                    workspaceSlug,
+                    agentModel: effectiveAgent.model,
+                    agentName: effectiveAgent.name,
+                    routeType: isDashboardMode
+                        ? dashboardChatTarget === "sow-master-dashboard"
+                            ? "MASTER_DASHBOARD"
+                            : "CLIENT_WORKSPACE"
+                        : "SOW_GENERATION",
+                });
+
+                // ðŸŒŠ STREAMING SUPPORT: Use stream-chat endpoint for AnythingLLM
+                const shouldStream = useAnythingLLM;
+                const streamEndpoint = endpoint.includes("/stream-chat")
+                    ? endpoint
+                    : endpoint.replace("/chat", "/stream-chat");
+
+                if (shouldStream) {
+                    // âœ¨ STREAMING MODE: Real-time response with thinking display
+                    const aiMessageId = `msg${Date.now() + 1}`;
+                    let accumulatedContent = "";
+
+                    // Create initial empty AI message
+                    const initialAIMessage: ChatMessage = {
+                        id: aiMessageId,
+                        role: "assistant",
+                        content: "",
+                        timestamp: Date.now(),
+                    };
+                    setChatMessages((prev) => [...prev, initialAIMessage]);
+                    setStreamingMessageId(aiMessageId);
+
+                    const response = await fetch(streamEndpoint, {
+                        method: "POST",
+                        headers: {
+                            "Content-Type": "application/json",
+                        },
+                        signal: controller.signal, // ðŸ›‘ Allow cancellation of this request
+                        body: JSON.stringify({
+                            model: effectiveAgent.model,
+                            workspace: workspaceSlug,
+                            threadSlug:
+                                !isDashboardMode && currentDocId
+                                    ? documents.find(
+                                          (d) => d.id === currentDocId,
+                                      )?.threadSlug || undefined
+                                    : undefined,
+                            messages: [
+                                {
+                                    role: "system",
+                                    content: effectiveAgent.systemPrompt,
+                                },
+                                ...newMessages.map((m) => ({
+                                    role: m.role,
+                                    content: m.content,
+                                })),
+                            ],
+                        }),
+                    });
+
+                    if (!response.ok) {
+                        const errorText = await response.text();
+                        let errorMessage =
+                            "Sorry, there was an error processing your request.";
+
+                        if (response.status === 400) {
+                            errorMessage =
+                                "âš ï¸ AnythingLLM error: Invalid request. Please check the workspace configuration.";
+                        } else if (
+                            response.status === 401 ||
+                            response.status === 403
+                        ) {
+                            errorMessage =
+                                "âš ï¸ AnythingLLM authentication failed. Please check the API key configuration.";
+                        } else if (response.status === 404) {
+                            errorMessage = `âš ï¸ AnythingLLM workspace '${workspaceSlug}' not found. Please verify it exists.`;
+                        }
+
+                        setChatMessages((prev) =>
+                            prev.map((msg) =>
+                                msg.id === aiMessageId
+                                    ? { ...msg, content: errorMessage }
+                                    : msg,
+                            ),
+                        );
+                        setStreamingMessageId(null);
                         return;
-                      }
+                    }
+
+                    // Read the SSE stream
+                    const reader = response.body?.getReader();
+                    const decoder = new TextDecoder();
 
-                      // Get HTML content from editor
-                      const htmlContent = editorRef.current?.getHTML() || '';
-                      
-                      if (!htmlContent || htmlContent === '<p></p>') {
-                        toast.error('âŒ Document is empty. Add content before sharing.');
+                    if (!reader) {
+                        console.error("âŒ No response body reader available");
+                        setStreamingMessageId(null);
+                        return;
+                    }
+
+                    try {
+                        let buffer = "";
+                        while (true) {
+                            const { done, value } = await reader.read();
+
+                            if (done) {
+                                console.log("âœ… Stream complete");
+                                setStreamingMessageId(null);
+                                break;
+                            }
+
+                            buffer += decoder.decode(value, { stream: true });
+                            const lines = buffer.split("\n");
+                            buffer = lines.pop() || "";
+
+                            for (const line of lines) {
+                                if (!line.trim() || !line.startsWith("data: "))
+                                    continue;
+
+                                try {
+                                    const jsonStr = line.substring(6); // Remove 'data: ' prefix
+                                    const data = JSON.parse(jsonStr);
+
+                                    // Handle different message types from AnythingLLM stream
+                                    if (
+                                        data.type === "textResponseChunk" &&
+                                        data.textResponse
+                                    ) {
+                                        accumulatedContent += data.textResponse;
+
+                                        // Update the message content in real-time
+                                        setChatMessages((prev) =>
+                                            prev.map((msg) =>
+                                                msg.id === aiMessageId
+                                                    ? {
+                                                          ...msg,
+                                                          content:
+                                                              accumulatedContent,
+                                                      }
+                                                    : msg,
+                                            ),
+                                        );
+                                    } else if (data.type === "textResponse") {
+                                        // Final response (fallback for non-chunked)
+                                        accumulatedContent =
+                                            data.content ||
+                                            data.textResponse ||
+                                            "";
+                                        setChatMessages((prev) =>
+                                            prev.map((msg) =>
+                                                msg.id === aiMessageId
+                                                    ? {
+                                                          ...msg,
+                                                          content:
+                                                              accumulatedContent,
+                                                      }
+                                                    : msg,
+                                            ),
+                                        );
+                                    }
+                                } catch (parseError) {
+                                    console.error(
+                                        "Failed to parse SSE data:",
+                                        parseError,
+                                    );
+                                }
+                            }
+                        }
+                    } catch (streamError) {
+                        console.error("âŒ Stream reading error:", streamError);
+                        setStreamingMessageId(null);
+                    }
+
+                    console.log(
+                        "âœ… Streaming complete, total content length:",
+                        accumulatedContent.length,
+                    );
+
+                    // ðŸŽ¯ Extract work type from the accumulated AI response
+                    const detectedWorkType =
+                        extractWorkType(accumulatedContent);
+
+                    // Update current document with detected work type
+                    if (currentDocId && detectedWorkType) {
+                        setDocuments((prev) =>
+                            prev.map((doc) =>
+                                doc.id === currentDocId
+                                    ? { ...doc, workType: detectedWorkType }
+                                    : doc,
+                            ),
+                        );
+                        console.log(
+                            `ðŸŽ¯ Updated document ${currentDocId} with work type: ${detectedWorkType}`,
+                        );
+                    }
+                } else {
+                    // ðŸ“¦ NON-STREAMING MODE: Standard fetch for OpenRouter
+                    const response = await fetch(endpoint, {
+                        method: "POST",
+                        headers: {
+                            "Content-Type": "application/json",
+                        },
+                        signal: controller.signal, // ðŸ›‘ Allow cancellation of this request
+                        body: JSON.stringify({
+                            model: effectiveAgent.model,
+                            workspace: workspaceSlug,
+                            threadSlug:
+                                !isDashboardMode && currentDocId
+                                    ? documents.find(
+                                          (d) => d.id === currentDocId,
+                                      )?.threadSlug || undefined
+                                    : undefined,
+                            messages: [
+                                {
+                                    role: "system",
+                                    content: effectiveAgent.systemPrompt,
+                                },
+                                ...newMessages.map((m) => ({
+                                    role: m.role,
+                                    content: m.content,
+                                })),
+                            ],
+                        }),
+                    });
+
+                    console.log(
+                        "ðŸ“¥ Response Status:",
+                        response.status,
+                        response.statusText,
+                    );
+                    const data = await response.json();
+
+                    if (!response.ok) {
+                        let errorMessage =
+                            "Sorry, there was an error processing your request.";
+
+                        if (response.status === 400) {
+                            errorMessage =
+                                "âš ï¸ OpenRouter API key not configured. Please set the OPENROUTER_API_KEY environment variable to enable AI chat functionality.";
+                        } else if (response.status === 402) {
+                            errorMessage =
+                                "Payment required: Please check your OpenRouter account balance or billing information.";
+                        } else if (response.status === 401) {
+                            errorMessage =
+                                "Authentication failed: Please check your OpenRouter API key.";
+                        } else if (response.status === 429) {
+                            errorMessage =
+                                "Rate limit exceeded: Please wait a moment before trying again.";
+                        } else if (data.error?.message) {
+                            errorMessage = `API Error: ${data.error.message}`;
+                        }
+
+                        const aiMessage: ChatMessage = {
+                            id: `msg${Date.now() + 1}`,
+                            role: "assistant",
+                            content: errorMessage,
+                            timestamp: Date.now(),
+                        };
+                        setChatMessages((prev) => [...prev, aiMessage]);
                         return;
-                      }
-
-                      // Embed to AnythingLLM (both client and master workspaces)
-                      await anythingLLM.embedSOWInBothWorkspaces(
-                        currentFolder.workspaceSlug,
-                        currentDoc.title,
-                        htmlContent
-                      );
-
-                      // 2. Generate portal URL
-                      const portalUrl = `${window.location.origin}/portal/sow/${currentDoc.id}`;
-                      
-                      // 3. Copy to clipboard with fallback
-                      if (navigator.clipboard && navigator.clipboard.writeText) {
-                        await navigator.clipboard.writeText(portalUrl)
-                          .then(() => toast.success('âœ… Portal link copied! SOW is now shareable.'))
-                          .catch(() => {
-                            // Fallback: Create temporary input and copy
-                            const input = document.createElement('input');
-                            input.value = portalUrl;
-                            document.body.appendChild(input);
-                            input.select();
-                            document.execCommand('copy');
-                            document.body.removeChild(input);
-                            toast.success('âœ… Portal link copied! SOW is now shareable.');
-                          });
-                      } else {
-                        // Fallback for older browsers
-                        const input = document.createElement('input');
-                        input.value = portalUrl;
-                        document.body.appendChild(input);
-                        input.select();
-                        document.execCommand('copy');
-                        document.body.removeChild(input);
-                        toast.success('âœ… Portal link copied! SOW is now shareable.');
-                      }
-                    } catch (error) {
-                      console.error('Error sharing portal:', error);
-                      toast.error(`âŒ Error preparing portal: ${error.message}`);
                     }
-                  }}
+
+                    const aiMessage: ChatMessage = {
+                        id: `msg${Date.now() + 1}`,
+                        role: "assistant",
+                        content:
+                            data.choices?.[0]?.message?.content ||
+                            "Sorry, I couldn't generate a response.",
+                        timestamp: Date.now(),
+                    };
+                    setChatMessages((prev) => [...prev, aiMessage]);
+                    console.log("âœ… Non-streaming response complete");
+                }
+            } catch (error) {
+                console.error("âŒ Chat API error:", error);
+
+                // Check if the error is an AbortError (request was cancelled)
+                if (error instanceof Error && error.name === "AbortError") {
+                    console.log(
+                        "â„¹ï¸ Request was cancelled to prevent rate limiting",
+                    );
+                    return;
+                }
+
+                // Check for rate limiting errors
+                let errorMessage =
+                    "âŒ Network error: Unable to reach AI service. Please check your connection and try again.";
+                if (error instanceof Error && error.message.includes("429")) {
+                    errorMessage =
+                        "â±ï¸ Rate limit exceeded: Please wait a moment before trying again.";
+                    toast.error("â±ï¸ Rate limited - waiting before retry...");
+                }
+
+                const errorMsg: ChatMessage = {
+                    id: `msg${Date.now() + 1}`,
+                    role: "assistant",
+                    content: errorMessage,
+                    timestamp: Date.now(),
+                };
+                const updatedMessages = [...newMessages, errorMsg];
+                setChatMessages(updatedMessages);
+
+                // âš ï¸ REMOVED DATABASE SAVE - AnythingLLM handles all message storage
+            } finally {
+                setIsChatLoading(false);
+                setCurrentRequestController(null); // Clean up the controller
+            }
+        } else {
+            setIsChatLoading(false);
+        }
+    };
+
+    // Prevent hydration errors by not rendering until mounted
+    if (!mounted) {
+        return null;
+    }
+
+    return (
+        <div className="flex flex-col h-screen bg-[#0e0f0f]">
+            {/* Onboarding Tutorial */}
+            <InteractiveOnboarding />
+
+            {/* Resizable Layout with Sidebar, Editor, and AI Chat */}
+            <div className="flex-1 h-full overflow-hidden">
+                <ResizableLayout
+                    sidebarOpen={sidebarOpen}
+                    aiChatOpen={agentSidebarOpen}
+                    onToggleSidebar={() => setSidebarOpen(!sidebarOpen)}
+                    onToggleAiChat={() =>
+                        setAgentSidebarOpen(!agentSidebarOpen)
+                    }
+                    viewMode={viewMode} // Pass viewMode for context awareness
+                    leftPanel={
+                        // Always show sidebar navigation regardless of view mode
+                        <SidebarNav
+                            workspaces={workspaces}
+                            currentWorkspaceId={currentWorkspaceId}
+                            currentSOWId={currentSOWId}
+                            currentView={viewMode}
+                            onSelectWorkspace={setCurrentWorkspaceId}
+                            onSelectSOW={setCurrentSOWId}
+                            onCreateWorkspace={handleCreateWorkspace}
+                            onRenameWorkspace={handleRenameWorkspace}
+                            onDeleteWorkspace={handleDeleteWorkspace}
+                            onCreateSOW={handleCreateSOW}
+                            onRenameSOW={handleRenameSOW}
+                            onDeleteSOW={handleDeleteSOW}
+                            onViewChange={handleViewChange}
+                            onToggleSidebar={() => setSidebarOpen(!sidebarOpen)}
+                            onReorderWorkspaces={handleReorderWorkspaces}
+                            onReorderSOWs={handleReorderSOWs}
+                        />
+                    }
+                    mainPanel={
+                        viewMode === "editor" ? (
+                            <div className="w-full h-full flex flex-col">
+                                {/* Document Status Bar - Only show when document is open */}
+                                {currentDoc && (
+                                    <DocumentStatusBar
+                                        title={
+                                            currentDoc.title ||
+                                            "Untitled Statement of Work"
+                                        }
+                                        saveStatus="saved"
+                                        isSaving={false}
+                                        onExportPDF={handleExportPDF}
+                                        onExportExcel={handleCreateGSheet}
+                                        onSharePortal={async () => {
+                                            if (!currentDoc) {
+                                                toast.error(
+                                                    "âŒ No document selected",
+                                                );
+                                                return;
+                                            }
+
+                                            toast.info(
+                                                "ðŸ“¤ Preparing portal link...",
+                                            );
+
+                                            try {
+                                                // 1. First, embed the SOW to AnythingLLM
+                                                const currentFolder =
+                                                    folders.find(
+                                                        (f) =>
+                                                            f.id ===
+                                                            currentDoc.folderId,
+                                                    );
+
+                                                if (
+                                                    !currentFolder ||
+                                                    !currentFolder.workspaceSlug
+                                                ) {
+                                                    toast.error(
+                                                        "âŒ No workspace found for this SOW",
+                                                    );
+                                                    return;
+                                                }
+
+                                                // Get HTML content from editor
+                                                const htmlContent =
+                                                    editorRef.current?.getHTML() ||
+                                                    "";
+
+                                                if (
+                                                    !htmlContent ||
+                                                    htmlContent === "<p></p>"
+                                                ) {
+                                                    toast.error(
+                                                        "âŒ Document is empty. Add content before sharing.",
+                                                    );
+                                                    return;
+                                                }
+
+                                                // Embed to AnythingLLM (both client and master workspaces)
+                                                await anythingLLM.embedSOWInBothWorkspaces(
+                                                    currentFolder.workspaceSlug,
+                                                    currentDoc.title,
+                                                    htmlContent,
+                                                );
+
+                                                // 2. Generate portal URL
+                                                const portalUrl = `${window.location.origin}/portal/sow/${currentDoc.id}`;
+
+                                                // 3. Copy to clipboard with fallback
+                                                if (
+                                                    navigator.clipboard &&
+                                                    navigator.clipboard
+                                                        .writeText
+                                                ) {
+                                                    await navigator.clipboard
+                                                        .writeText(portalUrl)
+                                                        .then(() =>
+                                                            toast.success(
+                                                                "âœ… Portal link copied! SOW is now shareable.",
+                                                            ),
+                                                        )
+                                                        .catch(() => {
+                                                            // Fallback: Create temporary input and copy
+                                                            const input =
+                                                                document.createElement(
+                                                                    "input",
+                                                                );
+                                                            input.value =
+                                                                portalUrl;
+                                                            document.body.appendChild(
+                                                                input,
+                                                            );
+                                                            input.select();
+                                                            document.execCommand(
+                                                                "copy",
+                                                            );
+                                                            document.body.removeChild(
+                                                                input,
+                                                            );
+                                                            toast.success(
+                                                                "âœ… Portal link copied! SOW is now shareable.",
+                                                            );
+                                                        });
+                                                } else {
+                                                    // Fallback for older browsers
+                                                    const input =
+                                                        document.createElement(
+                                                            "input",
+                                                        );
+                                                    input.value = portalUrl;
+                                                    document.body.appendChild(
+                                                        input,
+                                                    );
+                                                    input.select();
+                                                    document.execCommand(
+                                                        "copy",
+                                                    );
+                                                    document.body.removeChild(
+                                                        input,
+                                                    );
+                                                    toast.success(
+                                                        "âœ… Portal link copied! SOW is now shareable.",
+                                                    );
+                                                }
+                                            } catch (error) {
+                                                console.error(
+                                                    "Error sharing portal:",
+                                                    error,
+                                                );
+                                                toast.error(
+                                                    `âŒ Error preparing portal: ${error.message}`,
+                                                );
+                                            }
+                                        }}
+                                    />
+                                )}
+
+                                {/* Main Content Area */}
+                                <div className="flex-1 overflow-auto">
+                                    {currentDoc ? (
+                                        <div className="w-full h-full">
+                                            <TailwindAdvancedEditor
+                                                ref={editorRef}
+                                                initialContent={
+                                                    currentDoc.content
+                                                }
+                                                onUpdate={handleUpdateDoc}
+                                            />
+                                        </div>
+                                    ) : (
+                                        <div className="flex items-center justify-center h-full">
+                                            <div className="text-center">
+                                                <p className="text-gray-400 text-lg mb-4">
+                                                    No document selected
+                                                </p>
+                                                <p className="text-gray-500 text-sm">
+                                                    Create a new workspace to
+                                                    get started
+                                                </p>
+                                            </div>
+                                        </div>
+                                    )}
+                                </div>
+                            </div>
+                        ) : viewMode === "dashboard" ? (
+                            /* Dashboard temporarily hidden for now */
+                            <div style={{ display: "none" }} />
+                        ) : viewMode === "ai-management" ? (
+                            <div className="w-full h-full bg-[#0E0F0F]">
+                                <iframe
+                                    src="https://ahmad-anything-llm.840tjq.easypanel.host/"
+                                    className="w-full h-full border-0"
+                                    title="AI Management"
+                                    sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-pointer-lock allow-top-navigation allow-top-navigation-by-user-activation"
+                                    style={{
+                                        width: "100%",
+                                        height: "100%",
+                                        display: "block",
+                                        border: "none",
+                                    }}
+                                />
+                            </div>
+                        ) : (
+                            <GardnerStudio
+                                onSelectGardner={(slug) => {
+                                    // TODO: Route to Gardner chat
+                                    console.log("Selected Gardner:", slug);
+                                    toast.success(
+                                        "Gardner selected! Chat integration coming soon.",
+                                    );
+                                }}
+                            />
+                        )
+                    }
+                    rightPanel={
+                        // âœ¨ HIDE AI Chat panel completely in Gardner Studio and AI Management modes
+                        // Only show in editor and dashboard modes for a cleaner, context-appropriate UX
+                        viewMode === "editor" || viewMode === "dashboard" ? (
+                            <AgentSidebar
+                                isOpen={agentSidebarOpen}
+                                onToggle={() =>
+                                    setAgentSidebarOpen(!agentSidebarOpen)
+                                }
+                                agents={agents}
+                                currentAgentId={currentAgentId}
+                                onSelectAgent={handleSelectAgent}
+                                onCreateAgent={handleCreateAgent}
+                                onUpdateAgent={handleUpdateAgent}
+                                onDeleteAgent={handleDeleteAgent}
+                                chatMessages={chatMessages}
+                                onSendMessage={handleSendMessage}
+                                isLoading={isChatLoading}
+                                streamingMessageId={streamingMessageId}
+                                viewMode={viewMode} // Pass viewMode for context awareness
+                                dashboardChatTarget={dashboardChatTarget}
+                                onDashboardWorkspaceChange={
+                                    setDashboardChatTarget
+                                }
+                                availableWorkspaces={availableWorkspaces}
+                                onInsertToEditor={(content) => {
+                                    console.log(
+                                        "ðŸ“ Insert to Editor button clicked from AI chat",
+                                    );
+                                    // Clean all AI thinking tags before inserting
+                                    let cleanContent = content
+                                        .replace(
+                                            /<AI_THINK>[\s\S]*?<\/AI_THINK>/gi,
+                                            "",
+                                        )
+                                        .replace(
+                                            /<think>[\s\S]*?<\/think>/gi,
+                                            "",
+                                        )
+                                        .replace(
+                                            /<tool_call>[\s\S]*?<\/tool_call>/gi,
+                                            "",
+                                        )
+                                        .replace(/<\/?[A-Z_]+>/gi, "")
+                                        .trim();
+                                    handleInsertContent(
+                                        cleanContent || content,
+                                    );
+                                }}
+                            />
+                        ) : null // Return null to completely remove the panel from the component tree
+                    }
+                    leftMinSize={15}
+                    mainMinSize={30}
+                    rightMinSize={20}
+                    leftDefaultSize={20}
+                    mainDefaultSize={55}
+                    rightDefaultSize={25}
                 />
-              )}
-              
-              {/* Main Content Area */}
-              <div className="flex-1 overflow-auto">
-                {currentDoc ? (
-                  <div className="w-full h-full">
-                    <TailwindAdvancedEditor
-                      ref={editorRef}
-                      initialContent={currentDoc.content}
-                      onUpdate={handleUpdateDoc}
-                    />
-                  </div>
-                ) : (
-                  <div className="flex items-center justify-center h-full">
-                    <div className="text-center">
-                      <p className="text-gray-400 text-lg mb-4">No document selected</p>
-                      <p className="text-gray-500 text-sm">Create a new workspace to get started</p>
-                    </div>
-                  </div>
-                )}
-              </div>
             </div>
-          ) : viewMode === 'dashboard' ? (
-            /* Dashboard temporarily hidden for now */
-            <div style={{display:'none'}} />
-          ) : viewMode === 'ai-management' ? (
-            <div className="w-full h-full bg-[#0E0F0F]">
-              <iframe
-                src="https://ahmad-anything-llm.840tjq.easypanel.host/"
-                className="w-full h-full border-0"
-                title="AI Management"
-                sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-pointer-lock allow-top-navigation allow-top-navigation-by-user-activation"
-                style={{ width: '100%', height: '100%', display: 'block', border: 'none' }}
-              />
-            </div>
-          ) : (
-            <GardnerStudio onSelectGardner={(slug) => {
-              // TODO: Route to Gardner chat
-              console.log('Selected Gardner:', slug);
-              toast.success('Gardner selected! Chat integration coming soon.');
-            }} />
-          )
-        }
-        rightPanel={
-          // âœ¨ HIDE AI Chat panel completely in Gardner Studio and AI Management modes
-          // Only show in editor and dashboard modes for a cleaner, context-appropriate UX
-          viewMode === 'editor' || viewMode === 'dashboard' ? (
-            <AgentSidebar
-              isOpen={agentSidebarOpen}
-              onToggle={() => setAgentSidebarOpen(!agentSidebarOpen)}
-              agents={agents}
-              currentAgentId={currentAgentId}
-              onSelectAgent={handleSelectAgent}
-              onCreateAgent={handleCreateAgent}
-              onUpdateAgent={handleUpdateAgent}
-              onDeleteAgent={handleDeleteAgent}
-              chatMessages={chatMessages}
-              onSendMessage={handleSendMessage}
-              isLoading={isChatLoading}
-              streamingMessageId={streamingMessageId}
-              viewMode={viewMode} // Pass viewMode for context awareness
-              dashboardChatTarget={dashboardChatTarget}
-              onDashboardWorkspaceChange={setDashboardChatTarget}
-              availableWorkspaces={availableWorkspaces}
-              onInsertToEditor={(content) => {
-                console.log('ðŸ“ Insert to Editor button clicked from AI chat');
-                // Clean all AI thinking tags before inserting
-                let cleanContent = content
-                  .replace(/<AI_THINK>[\s\S]*?<\/AI_THINK>/gi, '')
-                  .replace(/<think>[\s\S]*?<\/think>/gi, '')
-                  .replace(/<tool_call>[\s\S]*?<\/tool_call>/gi, '')
-                  .replace(/<\/?[A-Z_]+>/gi, '')
-                  .trim();
-                handleInsertContent(cleanContent || content);
-              }}
+
+            {/* Send to Client Modal */}
+            {currentDoc && (
+                <SendToClientModal
+                    isOpen={showSendModal}
+                    onClose={() => setShowSendModal(false)}
+                    document={{
+                        id: currentDoc.id,
+                        title: currentDoc.title,
+                        content: currentDoc.content,
+                        totalInvestment: calculateTotalInvestment(
+                            currentDoc.content,
+                        ),
+                    }}
+                    onSuccess={(sowId, portalUrl) => {
+                        toast.success("SOW sent successfully!", {
+                            description: `Portal: ${portalUrl}`,
+                            duration: 5000,
+                        });
+                    }}
+                />
+            )}
+
+            {/* Share Link Modal */}
+            {shareModalData && (
+                <ShareLinkModal
+                    isOpen={showShareModal}
+                    onClose={() => {
+                        setShowShareModal(false);
+                        setShareModalData(null);
+                    }}
+                    shareLink={shareModalData.shareLink}
+                    documentTitle={shareModalData.documentTitle}
+                    shareCount={shareModalData.shareCount}
+                    firstShared={shareModalData.firstShared}
+                    lastShared={shareModalData.lastShared}
+                />
+            )}
+
+            {/* Workspace Creation Progress Modal */}
+            <WorkspaceCreationProgress
+                isOpen={workspaceCreationProgress.isOpen}
+                workspaceName={workspaceCreationProgress.workspaceName}
+                currentStep={workspaceCreationProgress.currentStep}
+                completedSteps={workspaceCreationProgress.completedSteps}
             />
-          ) : null // Return null to completely remove the panel from the component tree
-        }
-        leftMinSize={15}
-        mainMinSize={30}
-        rightMinSize={20}
-        leftDefaultSize={20}
-        mainDefaultSize={55}
-        rightDefaultSize={25}
-        />
-      </div>
-
-      {/* Send to Client Modal */}
-      {currentDoc && (
-        <SendToClientModal
-          isOpen={showSendModal}
-          onClose={() => setShowSendModal(false)}
-          document={{
-            id: currentDoc.id,
-            title: currentDoc.title,
-            content: currentDoc.content,
-            totalInvestment: calculateTotalInvestment(currentDoc.content),
-          }}
-          onSuccess={(sowId, portalUrl) => {
-            toast.success('SOW sent successfully!', {
-              description: `Portal: ${portalUrl}`,
-              duration: 5000,
-            });
-          }}
-        />
-      )}
-
-      {/* Share Link Modal */}
-      {shareModalData && (
-        <ShareLinkModal
-          isOpen={showShareModal}
-          onClose={() => {
-            setShowShareModal(false);
-            setShareModalData(null);
-          }}
-          shareLink={shareModalData.shareLink}
-          documentTitle={shareModalData.documentTitle}
-          shareCount={shareModalData.shareCount}
-          firstShared={shareModalData.firstShared}
-          lastShared={shareModalData.lastShared}
-        />
-      )}
-
-      {/* Workspace Creation Progress Modal */}
-      <WorkspaceCreationProgress
-        isOpen={workspaceCreationProgress.isOpen}
-        workspaceName={workspaceCreationProgress.workspaceName}
-        currentStep={workspaceCreationProgress.currentStep}
-        completedSteps={workspaceCreationProgress.completedSteps}
-      />
-
-      {/* Beautiful Onboarding Flow */}
-      <OnboardingFlow
-        isOpen={showOnboarding}
-        onComplete={() => setShowOnboarding(false)}
-        onCreateWorkspace={handleCreateWorkspace}
-        workspaceCount={workspaces.length}
-      />
-
-    </div>
-  );
+
+            {/* Beautiful Onboarding Flow */}
+            <OnboardingFlow
+                isOpen={showOnboarding}
+                onComplete={() => setShowOnboarding(false)}
+                onCreateWorkspace={handleCreateWorkspace}
+                workspaceCount={workspaces.length}
+            />
+        </div>
+    );
 }
diff --git a/frontend/lib/data-precedence.ts b/frontend/lib/data-precedence.ts
new file mode 100644
index 0000000..6b33458
--- /dev/null
+++ b/frontend/lib/data-precedence.ts
@@ -0,0 +1,504 @@
+// Data precedence controller - enforces business rule hierarchy
+// User-defined values ALWAYS override AI-generated values
+
+import { UserBusinessRules } from "./prompt-parser";
+
+export interface AIGeneratedData {
+    discount?: number;
+    scopes?: SOWScope[];
+    grand_total_pre_gst?: number;
+    gst_amount?: number;
+    grand_total?: number;
+    [key: string]: any;
+}
+
+export interface SOWScope {
+    id: number;
+    scope_name: string;
+    scope_description: string;
+    deliverables: string[];
+    assumptions: string[];
+    role_allocation: RoleAllocation[];
+    discount?: number;
+}
+
+export interface RoleAllocation {
+    role: string;
+    hours: number;
+    rate: number;
+    cost: number;
+}
+
+/**
+ * Applies data precedence hierarchy - user rules override AI values
+ * This is the core architectural component that prevents AI hallucinations
+ * from overriding explicit user business requirements
+ */
+export function applyDataPrecedence(
+    userRules: UserBusinessRules,
+    aiData: AIGeneratedData,
+    userPrompt: string = "",
+): AIGeneratedData {
+    console.log("ðŸ”§ [Data Precedence] Starting precedence application...");
+    console.log("ðŸ”§ [Data Precedence] User rules:", userRules);
+    console.log("ðŸ”§ [Data Precedence] AI data discount:", aiData.discount);
+
+    const result = { ...aiData };
+    let precedenceApplied = false;
+
+    // PRIORITY 1: MULTI-SERVICE SCOPE DETECTION
+    // Detect if this is a multi-service SOW (e.g., HubSpot + website)
+    if (userPrompt) {
+        const services = extractServicesFromPrompt(userPrompt);
+        if (services.length > 1) {
+            console.log(
+                `ðŸ”§ [Data Precedence] MULTI-SERVICE DETECTED: ${services.join(", ")}`,
+            );
+
+            // Ensure each scope has unique deliverables
+            if (result.scopes && result.scopes.length >= services.length) {
+                result.scopes = ensureUniqueScopes(result.scopes, services);
+                precedenceApplied = true;
+            }
+        }
+    }
+
+    // RULE 1: User discount ALWAYS overrides AI discount
+    if (userRules.discount !== undefined) {
+        const originalDiscount = result.discount;
+        result.discount = userRules.discount;
+        precedenceApplied = true;
+
+        console.log(
+            `ðŸ”§ [Data Precedence] DISCOUNT OVERRIDE: User (${userRules.discount}%) overrides AI (${originalDiscount}%)`,
+        );
+
+        // Recalculate financial totals with correct discount
+        if (result.scopes) {
+            result = recalculateFinancials(result, userRules.discount);
+        }
+    }
+
+    // RULE 2: User budget constraint overrides AI totals
+    if (userRules.budget !== undefined) {
+        const originalTotal = result.grand_total || 0;
+
+        if (originalTotal > userRules.budget) {
+            console.log(
+                `ðŸ”§ [Data Precedence] BUDGET CONSTRAINT: Target $${userRules.budget}, AI generated $${originalTotal}`,
+            );
+            result = adjustToBudget(
+                result,
+                userRules.budget,
+                userRules.gstApplicable,
+            );
+            precedenceApplied = true;
+        }
+    }
+
+    // RULE 3: User GST preference overrides AI assumption
+    if (userRules.gstApplicable !== undefined) {
+        // Recalculate GST based on user preference
+        result = recalculateGST(result, userRules.gstApplicable);
+        precedenceApplied = true;
+        console.log(
+            `ðŸ”§ [Data Precedence] GST OVERRIDE: User preference (${userRules.gstApplicable}) applied`,
+        );
+    }
+
+    if (precedenceApplied) {
+        console.log("âœ… [Data Precedence] Business rules successfully applied");
+        console.log("âœ… [Data Precedence] Final discount:", result.discount);
+        console.log("âœ… [Data Precedence] Final total:", result.grand_total);
+    } else {
+        console.log(
+            "â„¹ï¸ [Data Precedence] No user overrides needed, using AI values",
+        );
+    }
+
+    return result;
+}
+
+/**
+ * Recalculates all financial totals with the correct discount percentage
+ */
+function recalculateFinancials(
+    data: AIGeneratedData,
+    discountPercent: number,
+): AIGeneratedData {
+    const result = { ...data };
+
+    if (!result.scopes || !Array.isArray(result.scopes)) {
+        return result;
+    }
+
+    // Calculate subtotal from all scopes
+    let subtotal = 0;
+    result.scopes.forEach((scope) => {
+        if (scope.role_allocation && Array.isArray(scope.role_allocation)) {
+            const scopeTotal = scope.role_allocation.reduce(
+                (sum, role) => sum + (role.cost || 0),
+                0,
+            );
+            subtotal += scopeTotal;
+        }
+    });
+
+    // Apply discount
+    const discountAmount = subtotal * (discountPercent / 100);
+    const totalAfterDiscount = subtotal - discountAmount;
+
+    // Calculate GST (10% on post-discount amount)
+    const gstAmount = totalAfterDiscount * 0.1;
+    const finalTotal = totalAfterDiscount + gstAmount;
+
+    result.grand_total_pre_gst = totalAfterDiscount;
+    result.gst_amount = gstAmount;
+    result.grand_total = finalTotal;
+
+    console.log(`ðŸ”§ [Financial Recalc] Subtotal: $${subtotal.toFixed(2)}`);
+    console.log(
+        `ðŸ”§ [Financial Recalc] Discount (${discountPercent}%): -$${discountAmount.toFixed(2)}`,
+    );
+    console.log(
+        `ðŸ”§ [Financial Recalc] After Discount: $${totalAfterDiscount.toFixed(2)}`,
+    );
+    console.log(`ðŸ”§ [Financial Recalc] GST: $${gstAmount.toFixed(2)}`);
+    console.log(`ðŸ”§ [Financial Recalc] Final Total: $${finalTotal.toFixed(2)}`);
+
+    return result;
+}
+
+/**
+ * Adjusts scope hours/costs to meet user's budget constraint
+ */
+function adjustToBudget(
+    data: AIGeneratedData,
+    targetBudget: number,
+    gstApplicable: boolean = true,
+): AIGeneratedData {
+    const result = { ...data };
+
+    if (!result.scopes || !Array.isArray(result.scopes)) {
+        return result;
+    }
+
+    // Calculate target pre-GST amount
+    const targetPreGST = gstApplicable ? targetBudget / 1.1 : targetBudget;
+
+    // Calculate current subtotal
+    let currentSubtotal = 0;
+    result.scopes.forEach((scope) => {
+        if (scope.role_allocation && Array.isArray(scope.role_allocation)) {
+            const scopeTotal = scope.role_allocation.reduce(
+                (sum, role) => sum + (role.cost || 0),
+                0,
+            );
+            currentSubtotal += scopeTotal;
+        }
+    });
+
+    // Apply any existing discount
+    const discountPercent = result.discount || 0;
+    const currentAfterDiscount = currentSubtotal * (1 - discountPercent / 100);
+
+    if (currentAfterDiscount <= targetPreGST) {
+        // Already within budget - recalculate totals with correct discount
+        return recalculateFinancials(result, discountPercent);
+    }
+
+    // Calculate scaling factor to meet budget
+    const scalingFactor = targetPreGST / currentAfterDiscount;
+
+    console.log(
+        `ðŸ”§ [Budget Adjustment] Scaling factor: ${scalingFactor.toFixed(3)}`,
+    );
+    console.log(
+        `ðŸ”§ [Budget Adjustment] Target pre-GST: $${targetPreGST.toFixed(2)}`,
+    );
+
+    // Scale down all role hours proportionally
+    result.scopes.forEach((scope) => {
+        if (scope.role_allocation && Array.isArray(scope.role_allocation)) {
+            scope.role_allocation.forEach((role) => {
+                const originalHours = role.hours;
+                role.hours = Math.round(role.hours * scalingFactor * 4) / 4; // Round to nearest 0.25 hours
+                role.cost = role.hours * role.rate;
+
+                console.log(
+                    `ðŸ”§ [Budget Adjustment] ${role.role}: ${originalHours}h â†’ ${role.hours}h`,
+                );
+            });
+        }
+    });
+
+    // Recalculate totals with adjusted hours
+    const adjustedResult = recalculateFinancials(result, discountPercent);
+
+    // Double-check we're within budget
+    const adjustedPreGST = gstApplicable ? targetBudget / 1.1 : targetBudget;
+    const finalTotal = adjustedResult.grand_total || 0;
+    const finalPreGST = adjustedResult.grand_total_pre_gst || 0;
+
+    if (finalPreGST > adjustedPreGST) {
+        console.warn(
+            `âš ï¸ [Budget Adjustment] Still over budget after scaling. Adjusting discount.`,
+        );
+        // If still over budget, apply additional discount
+        const extraDiscountPercent = Math.min(
+            20,
+            ((finalPreGST - adjustedPreGST) / finalPreGST) * 100,
+        );
+        return recalculateFinancials(
+            adjustedResult,
+            discountPercent + extraDiscountPercent,
+        );
+    }
+
+    return adjustedResult;
+}
+
+/**
+ * Recalculates GST based on user preference
+ */
+function recalculateGST(
+    data: AIGeneratedData,
+    gstApplicable: boolean,
+): AIGeneratedData {
+    const result = { ...data };
+
+    const preGSTTotal = result.grand_total_pre_gst || 0;
+
+    if (gstApplicable) {
+        result.gst_amount = preGSTTotal * 0.1;
+        result.grand_total = preGSTTotal + result.gst_amount;
+    } else {
+        result.gst_amount = 0;
+        result.grand_total = preGSTTotal;
+    }
+
+    // Log for debugging
+    console.log(`ðŸ”§ [GST Recalculation] GST Applicable: ${gstApplicable}`);
+    console.log(
+        `ðŸ”§ [GST Recalculation] Pre-GST Total: $${preGSTTotal.toFixed(2)}`,
+    );
+    console.log(
+        `ðŸ”§ [GST Recalculation] GST Amount: $${result.gst_amount.toFixed(2)}`,
+    );
+    console.log(
+        `ðŸ”§ [GST Recalculation] Final Total: $${result.grand_total.toFixed(2)}`,
+    );
+
+    return result;
+}
+
+/**
+ * Extracts distinct services from user prompt to identify multi-service SOWs
+ */
+export function extractServicesFromPrompt(prompt: string): string[] {
+    const services: string[] = [];
+    const lowerPrompt = prompt.toLowerCase();
+
+    // Common service patterns
+    const servicePatterns = [
+        { pattern: /\bhubspot\b/i, name: "HubSpot" },
+        {
+            pattern: /\bwebsite\b.*\b(build|development|creation)\b/i,
+            name: "Website",
+        },
+        { pattern: /\bmigration\b/i, name: "Migration" },
+        { pattern: /\bintegration\b/i, name: "Integration" },
+        { pattern: /\bseo\b/i, name: "SEO" },
+        { pattern: /\bsocial\s*media\b/i, name: "Social Media" },
+        { pattern: /\bcontent\s*(marketing|creation)\b/i, name: "Content" },
+    ];
+
+    servicePatterns.forEach(({ pattern, name }) => {
+        if (pattern.test(lowerPrompt)) {
+            services.push(name);
+        }
+    });
+
+    return [...new Set(services)]; // Remove duplicates
+}
+
+/**
+ * Ensures each scope has unique deliverables for multi-service SOWs
+ */
+export function ensureUniqueScopes(
+    scopes: SOWScope[],
+    services: string[],
+): SOWScope[] {
+    return scopes.map((scope, index) => {
+        if (index < services.length) {
+            // Create unique deliverables for each service
+            const uniqueDeliverables = createServiceSpecificDeliverables(
+                services[index],
+                scope.scope_description || "",
+            );
+
+            return {
+                ...scope,
+                scope_name: `${services[index]} Implementation`,
+                deliverables: uniqueDeliverables,
+            };
+        }
+        return scope;
+    });
+}
+
+/**
+ * Creates service-specific deliverables based on service type
+ */
+function createServiceSpecificDeliverables(
+    service: string,
+    description: string,
+): string[] {
+    const baseDeliverables = [
+        "Project kickoff and requirements gathering",
+        "Regular progress updates and status reporting",
+        "Final delivery and handover documentation",
+    ];
+
+    switch (service) {
+        case "HubSpot":
+            return [
+                ...baseDeliverables,
+                "HubSpot setup and configuration",
+                "Data migration to HubSpot",
+                "Custom property and workflow creation",
+                "Team training and user onboarding",
+            ];
+
+        case "Website":
+            return [
+                ...baseDeliverables,
+                "Website design mockups",
+                "Frontend development",
+                "Backend integration",
+                "Content management system setup",
+                "Responsive design implementation",
+                "Testing and quality assurance",
+            ];
+
+        case "Migration":
+            return [
+                ...baseDeliverables,
+                "Source system analysis and mapping",
+                "Data extraction and cleansing",
+                "Data transformation and validation",
+                "Target system implementation",
+                "Post-migration verification",
+            ];
+
+        default:
+            return baseDeliverables;
+    }
+}
+
+/**
+ * Validates that precedence was applied correctly
+ */
+export function validatePrecedenceApplication(
+    userRules: UserBusinessRules,
+    finalData: AIGeneratedData,
+): { valid: boolean; violations: string[] } {
+    const violations: string[] = [];
+
+    // Check discount precedence
+    if (
+        userRules.discount !== undefined &&
+        finalData.discount !== userRules.discount
+    ) {
+        violations.push(
+            `Discount precedence violation: Expected ${userRules.discount}%, got ${finalData.discount}%`,
+        );
+    }
+
+    // Check budget constraint
+    if (
+        userRules.budget !== undefined &&
+        finalData.grand_total &&
+        finalData.grand_total > userRules.budget * 1.01
+    ) {
+        violations.push(
+            `Budget constraint violation: Expected â‰¤$${userRules.budget}, got $${finalData.grand_total.toFixed(2)}`,
+        );
+    }
+
+    // Check for content duplication in multi-service SOWs
+    if (finalData.scopes && finalData.scopes.length > 1) {
+        const duplicateDeliverables = findDuplicateDeliverables(
+            finalData.scopes,
+        );
+        if (duplicateDeliverables.length > 0) {
+            violations.push(
+                `Content duplication detected across scopes: ${duplicateDeliverables.join(", ")}`,
+            );
+        }
+    }
+
+    return {
+        valid: violations.length === 0,
+        violations,
+    };
+}
+
+/**
+ * Finds deliverables that appear in multiple scopes (content duplication bug)
+ */
+function findDuplicateDeliverables(scopes: SOWScope[]): string[] {
+    const allDeliverables: string[] = [];
+    const duplicates: string[] = [];
+
+    scopes.forEach((scope) => {
+        if (scope.deliverables) {
+            scope.deliverables.forEach((deliverable) => {
+                const normalized = deliverable.toLowerCase().trim();
+                if (allDeliverables.includes(normalized)) {
+                    if (!duplicates.includes(normalized)) {
+                        duplicates.push(normalized);
+                    }
+                } else {
+                    allDeliverables.push(normalized);
+                }
+            });
+        }
+    });
+
+    return duplicates;
+}
+
+/**
+ * Logs precedence application for debugging
+ */
+export function logPrecedenceApplication(
+    userRules: UserBusinessRules,
+    originalAI: AIGeneratedData,
+    finalData: AIGeneratedData,
+): void {
+    console.log("ðŸ“Š [Data Precedence] Application Summary:");
+    console.log("ðŸ“Š [Data Precedence] User Rules:", userRules);
+    console.log(
+        "ðŸ“Š [Data Precedence] Original AI Discount:",
+        originalAI.discount,
+    );
+    console.log("ðŸ“Š [Data Precedence] Final Discount:", finalData.discount);
+    console.log(
+        "ðŸ“Š [Data Precedence] Original AI Total:",
+        originalAI.grand_total,
+    );
+    console.log("ðŸ“Š [Data Precedence] Final Total:", finalData.grand_total);
+
+    const validation = validatePrecedenceApplication(userRules, finalData);
+    if (validation.valid) {
+        console.log(
+            "âœ… [Data Precedence] All business rules correctly applied",
+        );
+    } else {
+        console.error(
+            "âŒ [Data Precedence] Violations detected:",
+            validation.violations,
+        );
+    }
+}
diff --git a/frontend/lib/export-utils.ts b/frontend/lib/export-utils.ts
index 0837be5..073ff84 100644
--- a/frontend/lib/export-utils.ts
+++ b/frontend/lib/export-utils.ts
@@ -1,356 +1,418 @@
 // Export utilities for SOW documents
-import jsPDF from 'jspdf';
-import html2canvas from 'html2canvas';
-import * as XLSX from 'xlsx';
+import jsPDF from "jspdf";
+import html2canvas from "html2canvas";
+import * as XLSX from "xlsx";
 
 export interface PricingRow {
-  role: string;
-  hours: number;
-  rate: number;
-  total: number;
+    role: string;
+    hours: number;
+    rate: number;
+    total: number;
 }
 
 export interface SOWData {
-  title: string;
-  client?: string;
-  overview?: string;
-  deliverables?: string[];
-  pricingRows: PricingRow[];
-  discount?: { type: 'percentage' | 'fixed'; value: number };
-  showGST?: boolean;
-  assumptions?: string[];
-  timeline?: string;
+    title: string;
+    client?: string;
+    overview?: string;
+    deliverables?: string[];
+    pricingRows: PricingRow[];
+    discount?: { type: "percentage" | "fixed"; value: number };
+    showGST?: boolean;
+    assumptions?: string[];
+    timeline?: string;
 }
 
 /**
  * Extract pricing data from Novel editor content
  */
 export function extractPricingFromContent(content: any): PricingRow[] {
-  const rows: PricingRow[] = [];
-  
-  if (!content || !content.content) return rows;
-
-  const findTables = (nodes: any[]): void => {
-    nodes.forEach((node: any) => {
-      if (node.type === 'table' && node.content) {
-        // Skip header row, process data rows
-        const dataRows = node.content.slice(1);
-        
-        dataRows.forEach((row: any) => {
-          if (row.type === 'tableRow' && row.content && row.content.length >= 4) {
-            const cells = row.content;
-            const role = cells[0]?.content?.[0]?.content?.[0]?.text || '';
-            const hours = parseFloat(cells[1]?.content?.[0]?.content?.[0]?.text || '0');
-            const rateText = cells[2]?.content?.[0]?.content?.[0]?.text || '';
-            const rate = parseFloat(rateText.replace(/[$,]/g, ''));
-            const totalText = cells[3]?.content?.[0]?.content?.[0]?.text || '';
-            const total = parseFloat(totalText.replace(/[$,+GST]/g, ''));
-            
-            if (role && !role.includes('Total') && !role.includes('Role')) {
-              rows.push({ role, hours, rate, total });
+    const rows: PricingRow[] = [];
+
+    if (!content || !content.content) return rows;
+
+    const findTables = (nodes: any[]): void => {
+        nodes.forEach((node: any) => {
+            if (node.type === "table" && node.content) {
+                // Skip header row, process data rows
+                const dataRows = node.content.slice(1);
+
+                dataRows.forEach((row: any) => {
+                    if (
+                        row.type === "tableRow" &&
+                        row.content &&
+                        row.content.length >= 4
+                    ) {
+                        const cells = row.content;
+                        const role =
+                            cells[0]?.content?.[0]?.content?.[0]?.text || "";
+                        const hours = parseFloat(
+                            cells[1]?.content?.[0]?.content?.[0]?.text || "0",
+                        );
+                        const rateText =
+                            cells[2]?.content?.[0]?.content?.[0]?.text || "";
+                        const rate = parseFloat(rateText.replace(/[$,]/g, ""));
+                        const totalText =
+                            cells[3]?.content?.[0]?.content?.[0]?.text || "";
+                        const total = parseFloat(
+                            totalText.replace(/[$,+GST]/g, ""),
+                        );
+
+                        if (
+                            role &&
+                            !role.includes("Total") &&
+                            !role.includes("Role")
+                        ) {
+                            rows.push({ role, hours, rate, total });
+                        }
+                    }
+                });
+            }
+
+            if (node.content) {
+                findTables(node.content);
             }
-          }
         });
-      }
-      
-      if (node.content) {
-        findTables(node.content);
-      }
-    });
-  };
+    };
 
-  findTables(content.content);
-  return rows;
+    findTables(content.content);
+    return rows;
 }
 
 /**
  * Calculate totals with optional discount
  */
-export function calculateTotals(rows: PricingRow[], discount?: { type: 'percentage' | 'fixed'; value: number }) {
-  const subtotal = rows.reduce((sum, row) => sum + row.total, 0);
-  const totalHours = rows.reduce((sum, row) => sum + row.hours, 0);
-  
-  let discountAmount = 0;
-  if (discount) {
-    if (discount.type === 'percentage') {
-      discountAmount = subtotal * (discount.value / 100);
-    } else {
-      discountAmount = discount.value;
+export function calculateTotals(
+    rows: PricingRow[],
+    discount?: { type: "percentage" | "fixed"; value: number },
+) {
+    const subtotal = rows.reduce((sum, row) => sum + row.total, 0);
+    const totalHours = rows.reduce((sum, row) => sum + row.hours, 0);
+
+    let discountAmount = 0;
+    if (discount) {
+        if (discount.type === "percentage") {
+            discountAmount = subtotal * (discount.value / 100);
+        } else {
+            discountAmount = discount.value;
+        }
     }
-  }
-  
-  const grandTotal = subtotal - discountAmount;
-  
-  return {
-    subtotal,
-    totalHours,
-    discountAmount,
-    grandTotal,
-    gstAmount: grandTotal * 0.1, // 10% GST
-  };
+
+    const grandTotal = subtotal - discountAmount;
+
+    return {
+        subtotal,
+        totalHours,
+        discountAmount,
+        grandTotal,
+        gstAmount: grandTotal * 0.1, // 10% GST
+    };
 }
 
 /**
  * Export pricing table to CSV
  */
-export function exportToCSV(sowData: SOWData, filename: string = 'sow-pricing.csv') {
-  const { pricingRows, discount } = sowData;
-  const totals = calculateTotals(pricingRows, discount);
-  
-  // Create data array for CSV
-  const data: any[] = [
-    ['Social Garden - Scope of Work Pricing'],
-    [''],
-    ['Role', 'Hours', 'Rate (AUD)', 'Total (AUD)'],
-  ];
-  
-  pricingRows.forEach(row => {
+export function exportToCSV(
+    sowData: SOWData,
+    filename: string = "sow-pricing.csv",
+) {
+    const { pricingRows, discount } = sowData;
+    const totals = calculateTotals(pricingRows, discount);
+
+    // Create data array for CSV
+    const data: any[] = [
+        ["Social Garden - Scope of Work Pricing"],
+        [""],
+        ["Role", "Hours", "Rate (AUD)", "Total (AUD)"],
+    ];
+
+    pricingRows.forEach((row) => {
+        data.push([
+            row.role,
+            row.hours,
+            `$${row.rate}`,
+            `$${row.total.toFixed(2)} +GST`,
+        ]);
+    });
+
+    data.push([""]);
+    data.push(["Total Hours", totals.totalHours, "", ""]);
+    data.push(["Sub-Total", "", "", `$${totals.subtotal.toFixed(2)} +GST`]);
+
+    if (discount && totals.discountAmount > 0) {
+        const discountLabel =
+            discount.type === "percentage"
+                ? `Discount (${discount.value}%)`
+                : "Discount";
+        data.push([
+            discountLabel,
+            "",
+            "",
+            `-$${totals.discountAmount.toFixed(2)}`,
+        ]);
+    }
+
+    data.push(["Grand Total", "", "", `$${totals.grandTotal.toFixed(2)} +GST`]);
+    data.push(["GST (10%)", "", "", `$${totals.gstAmount.toFixed(2)}`]);
     data.push([
-      row.role,
-      row.hours,
-      `$${row.rate}`,
-      `$${row.total.toFixed(2)} +GST`
+        "Total Inc. GST",
+        "",
+        "",
+        `$${(totals.grandTotal + totals.gstAmount).toFixed(2)}`,
     ]);
-  });
-  
-  data.push(['']);
-  data.push(['Total Hours', totals.totalHours, '', '']);
-  data.push(['Sub-Total', '', '', `$${totals.subtotal.toFixed(2)} +GST`]);
-  
-  if (discount && totals.discountAmount > 0) {
-    const discountLabel = discount.type === 'percentage' 
-      ? `Discount (${discount.value}%)` 
-      : 'Discount';
-    data.push([discountLabel, '', '', `-$${totals.discountAmount.toFixed(2)}`]);
-  }
-  
-  data.push(['Grand Total', '', '', `$${totals.grandTotal.toFixed(2)} +GST`]);
-  data.push(['GST (10%)', '', '', `$${totals.gstAmount.toFixed(2)}`]);
-  data.push(['Total Inc. GST', '', '', `$${(totals.grandTotal + totals.gstAmount).toFixed(2)}`]);
-  
-  // Convert to CSV string
-  const csvContent = data.map(row => row.join(',')).join('\n');
-  
-  // Download
-  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
-  const link = document.createElement('a');
-  link.href = URL.createObjectURL(blob);
-  link.download = filename;
-  link.click();
+
+    // Convert to CSV string
+    const csvContent = data.map((row) => row.join(",")).join("\n");
+
+    // Download
+    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
+    const link = document.createElement("a");
+    link.href = URL.createObjectURL(blob);
+    link.download = filename;
+    link.click();
 }
 
 /**
  * Export pricing table to Excel
  */
-export function exportToExcel(sowData: SOWData, filename: string = 'sow-pricing.xlsx') {
-  const { pricingRows, discount, title } = sowData;
-  const totals = calculateTotals(pricingRows, discount);
-  
-  // Create worksheet data
-  const wsData: any[] = [
-    ['Social Garden - Scope of Work'],
-    [title || 'Statement of Work'],
-    [''],
-    ['Role', 'Hours', 'Rate (AUD)', 'Total (AUD)'],
-  ];
-  
-  pricingRows.forEach(row => {
+export function exportToExcel(
+    sowData: SOWData,
+    filename: string = "sow-pricing.xlsx",
+) {
+    const { pricingRows, discount, title } = sowData;
+    const totals = calculateTotals(pricingRows, discount);
+
+    // Create worksheet data
+    const wsData: any[] = [
+        ["Social Garden - Scope of Work"],
+        [title || "Statement of Work"],
+        [""],
+        ["Role", "Hours", "Rate (AUD)", "Total (AUD)"],
+    ];
+
+    pricingRows.forEach((row) => {
+        wsData.push([row.role, row.hours, row.rate, row.total]);
+    });
+
+    wsData.push([""]);
+    wsData.push(["Total Hours", totals.totalHours, "", ""]);
+    wsData.push(["Sub-Total (excl. GST)", "", "", totals.subtotal]);
+
+    if (discount && totals.discountAmount > 0) {
+        const discountLabel =
+            discount.type === "percentage"
+                ? `Discount (${discount.value}%)`
+                : "Discount";
+        wsData.push([discountLabel, "", "", -totals.discountAmount]);
+    }
+
+    wsData.push(["Grand Total (excl. GST)", "", "", totals.grandTotal]);
+    wsData.push(["GST (10%)", "", "", totals.gstAmount]);
     wsData.push([
-      row.role,
-      row.hours,
-      row.rate,
-      row.total
+        "Total Inc. GST",
+        "",
+        "",
+        totals.grandTotal + totals.gstAmount,
     ]);
-  });
-  
-  wsData.push(['']);
-  wsData.push(['Total Hours', totals.totalHours, '', '']);
-  wsData.push(['Sub-Total (excl. GST)', '', '', totals.subtotal]);
-  
-  if (discount && totals.discountAmount > 0) {
-    const discountLabel = discount.type === 'percentage' 
-      ? `Discount (${discount.value}%)` 
-      : 'Discount';
-    wsData.push([discountLabel, '', '', -totals.discountAmount]);
-  }
-  
-  wsData.push(['Grand Total (excl. GST)', '', '', totals.grandTotal]);
-  wsData.push(['GST (10%)', '', '', totals.gstAmount]);
-  wsData.push(['Total Inc. GST', '', '', totals.grandTotal + totals.gstAmount]);
-  
-  // Create workbook and worksheet
-  const wb = XLSX.utils.book_new();
-  const ws = XLSX.utils.aoa_to_sheet(wsData);
-  
-  // Set column widths
-  ws['!cols'] = [
-    { wch: 50 },  // Role
-    { wch: 10 },  // Hours
-    { wch: 15 },  // Rate
-    { wch: 20 },  // Total
-  ];
-  
-  XLSX.utils.book_append_sheet(wb, ws, 'SOW Pricing');
-  XLSX.writeFile(wb, filename);
+
+    // Create workbook and worksheet
+    const wb = XLSX.utils.book_new();
+    const ws = XLSX.utils.aoa_to_sheet(wsData);
+
+    // Set column widths
+    ws["!cols"] = [
+        { wch: 50 }, // Role
+        { wch: 10 }, // Hours
+        { wch: 15 }, // Rate
+        { wch: 20 }, // Total
+    ];
+
+    XLSX.utils.book_append_sheet(wb, ws, "SOW Pricing");
+
+    // Return blob for API usage
+    const excelBuffer = XLSX.write(wb, { bookType: "xlsx", type: "array" });
+    return new Blob([excelBuffer], {
+        type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
+    });
 }
 
 /**
  * Generate PDF from HTML content
  */
 export async function exportToPDF(
-  element: HTMLElement,
-  filename: string = 'sow-document.pdf',
-  options?: {
-    showLogo?: boolean;
-    logoUrl?: string;
-    title?: string;
-  }
+    element: HTMLElement,
+    filename: string = "sow-document.pdf",
+    options?: {
+        showLogo?: boolean;
+        logoUrl?: string;
+        title?: string;
+    },
 ) {
-  try {
-    // Create canvas from HTML element
-    const canvas = await html2canvas(element, {
-      scale: 2,
-      useCORS: true,
-      logging: false,
-    });
-    
-    const imgData = canvas.toDataURL('image/png');
-    const pdf = new jsPDF({
-      orientation: 'portrait',
-      unit: 'mm',
-      format: 'a4',
-    });
-    
-    // Calculate dimensions
-    const pdfWidth = pdf.internal.pageSize.getWidth();
-    const pdfHeight = pdf.internal.pageSize.getHeight();
-    const canvasWidth = canvas.width;
-    const canvasHeight = canvas.height;
-    const ratio = canvasWidth / canvasHeight;
-    const width = pdfWidth - 20; // 10mm margins
-    const height = width / ratio;
-    
-    // Add logo if provided
-    if (options?.showLogo && options?.logoUrl) {
-      try {
-        pdf.addImage(options.logoUrl, 'PNG', 10, 10, 40, 15);
-      } catch (error) {
-        console.error('Error adding logo to PDF:', error);
-      }
-    }
-    
-    // Add title if provided
-    if (options?.title) {
-      pdf.setFontSize(16);
-      pdf.setTextColor(44, 130, 61); // Social Garden green
-      pdf.text(options.title, 10, options?.showLogo ? 35 : 20);
-    }
-    
-    // Add content
-    const yOffset = options?.title ? (options?.showLogo ? 45 : 30) : (options?.showLogo ? 30 : 10);
-    let remainingHeight = height;
-    let yPosition = yOffset;
-    
-    // Add pages as needed
-    while (remainingHeight > 0) {
-      pdf.addImage(
-        imgData,
-        'PNG',
-        10,
-        yPosition,
-        width,
-        Math.min(remainingHeight, pdfHeight - yPosition - 10)
-      );
-      
-      remainingHeight -= (pdfHeight - yPosition - 10);
-      
-      if (remainingHeight > 0) {
-        pdf.addPage();
-        yPosition = 10;
-      }
+    try {
+        // Create canvas from HTML element
+        const canvas = await html2canvas(element, {
+            scale: 2,
+            useCORS: true,
+            logging: false,
+        });
+
+        const imgData = canvas.toDataURL("image/png");
+        const pdf = new jsPDF({
+            orientation: "portrait",
+            unit: "mm",
+            format: "a4",
+        });
+
+        // Calculate dimensions
+        const pdfWidth = pdf.internal.pageSize.getWidth();
+        const pdfHeight = pdf.internal.pageSize.getHeight();
+        const canvasWidth = canvas.width;
+        const canvasHeight = canvas.height;
+        const ratio = canvasWidth / canvasHeight;
+        const width = pdfWidth - 20; // 10mm margins
+        const height = width / ratio;
+
+        // Add logo if provided
+        if (options?.showLogo && options?.logoUrl) {
+            try {
+                pdf.addImage(options.logoUrl, "PNG", 10, 10, 40, 15);
+            } catch (error) {
+                console.error("Error adding logo to PDF:", error);
+            }
+        }
+
+        // Add title if provided
+        if (options?.title) {
+            pdf.setFontSize(16);
+            pdf.setTextColor(44, 130, 61); // Social Garden green
+            pdf.text(options.title, 10, options?.showLogo ? 35 : 20);
+        }
+
+        // Add content
+        const yOffset = options?.title
+            ? options?.showLogo
+                ? 45
+                : 30
+            : options?.showLogo
+              ? 30
+              : 10;
+        let remainingHeight = height;
+        let yPosition = yOffset;
+
+        // Add pages as needed
+        while (remainingHeight > 0) {
+            pdf.addImage(
+                imgData,
+                "PNG",
+                10,
+                yPosition,
+                width,
+                Math.min(remainingHeight, pdfHeight - yPosition - 10),
+            );
+
+            remainingHeight -= pdfHeight - yPosition - 10;
+
+            if (remainingHeight > 0) {
+                pdf.addPage();
+                yPosition = 10;
+            }
+        }
+
+        // Return blob for API usage instead of direct download
+        const pdfBlob = pdf.output("blob");
+        return pdfBlob;
+    } catch (error) {
+        console.error("Error generating PDF:", error);
+        return null;
     }
-    
-    pdf.save(filename);
-    return true;
-  } catch (error) {
-    console.error('Error generating PDF:', error);
-    return false;
-  }
 }
 
 /**
  * Format currency for display
  */
-export function formatCurrency(amount: number, showGST: boolean = true): string {
-  const formatted = `$${amount.toLocaleString('en-AU', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
-  return showGST ? `${formatted} +GST` : formatted;
+export function formatCurrency(
+    amount: number,
+    showGST: boolean = true,
+): string {
+    const formatted = `$${amount.toLocaleString("en-AU", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
+    return showGST ? `${formatted} +GST` : formatted;
 }
 
 /**
  * Parse markdown SOW content and extract structured data
  */
 export function parseSOWMarkdown(markdown: string): Partial<SOWData> {
-  const lines = markdown.split('\n');
-  const data: Partial<SOWData> = {
-    pricingRows: [],
-    deliverables: [],
-    assumptions: [],
-  };
-  
-  // Extract title (first H1)
-  const titleMatch = markdown.match(/^#\s+(.+)$/m);
-  if (titleMatch) {
-    data.title = titleMatch[1];
-  }
-  
-  // Extract client name
-  const clientMatch = markdown.match(/\*\*Client:\*\*\s+(.+)$/m);
-  if (clientMatch) {
-    data.client = clientMatch[1];
-  }
-  
-  // Extract overview
-  const overviewMatch = markdown.match(/##\s+Overview\s+(.+?)(?=##|$)/s);
-  if (overviewMatch) {
-    data.overview = overviewMatch[1].trim();
-  }
-  
-  // Extract deliverables
-  const deliverablesMatch = markdown.match(/##\s+What does the scope include\?\s+(.+?)(?=##|$)/s);
-  if (deliverablesMatch) {
-    const deliverableLines = deliverablesMatch[1].trim().split('\n');
-    data.deliverables = deliverableLines
-      .filter(line => line.trim().startsWith('â€¢') || line.trim().startsWith('-') || line.trim().startsWith('+'))
-      .map(line => line.replace(/^[â€¢\-+]\s*/, '').trim());
-  }
-  
-  // Extract discount info
-  const discountMatch = markdown.match(/Discount\s+\((\d+)%\):\s*-?\$?([\d,]+\.?\d*)/i);
-  if (discountMatch) {
-    data.discount = {
-      type: 'percentage',
-      value: parseFloat(discountMatch[1]),
+    const lines = markdown.split("\n");
+    const data: Partial<SOWData> = {
+        pricingRows: [],
+        deliverables: [],
+        assumptions: [],
     };
-  }
-  
-  return data;
+
+    // Extract title (first H1)
+    const titleMatch = markdown.match(/^#\s+(.+)$/m);
+    if (titleMatch) {
+        data.title = titleMatch[1];
+    }
+
+    // Extract client name
+    const clientMatch = markdown.match(/\*\*Client:\*\*\s+(.+)$/m);
+    if (clientMatch) {
+        data.client = clientMatch[1];
+    }
+
+    // Extract overview
+    const overviewMatch = markdown.match(/##\s+Overview\s+(.+?)(?=##|$)/s);
+    if (overviewMatch) {
+        data.overview = overviewMatch[1].trim();
+    }
+
+    // Extract deliverables
+    const deliverablesMatch = markdown.match(
+        /##\s+What does the scope include\?\s+(.+?)(?=##|$)/s,
+    );
+    if (deliverablesMatch) {
+        const deliverableLines = deliverablesMatch[1].trim().split("\n");
+        data.deliverables = deliverableLines
+            .filter(
+                (line) =>
+                    line.trim().startsWith("â€¢") ||
+                    line.trim().startsWith("-") ||
+                    line.trim().startsWith("+"),
+            )
+            .map((line) => line.replace(/^[â€¢\-+]\s*/, "").trim());
+    }
+
+    // Extract discount info
+    const discountMatch = markdown.match(
+        /Discount\s+\((\d+)%\):\s*-?\$?([\d,]+\.?\d*)/i,
+    );
+    if (discountMatch) {
+        data.discount = {
+            type: "percentage",
+            value: parseFloat(discountMatch[1]),
+        };
+    }
+
+    return data;
 }
 
 /**
  * Clean SOW content by removing non-client-facing elements
  */
 export function cleanSOWContent(content: string): string {
-  // Remove any internal comments, thinking tags, tool calls, etc.
-  return content
-    // Remove <AI_THINK> tags
-    .replace(/<AI_THINK>[\s\S]*?<\/AI_THINK>/gi, '')
-    // Remove <think> tags
-    .replace(/<think>[\s\S]*?<\/think>/gi, '')
-    // Remove <tool_call> tags
-    .replace(/<tool_call>[\s\S]*?<\/tool_call>/gi, '')
-    // Remove HTML comments
-    .replace(/<!-- .*? -->/gi, '')
-    // Remove any remaining XML-style tags that might be internal
-    .replace(/<\/?[A-Z_]+>/gi, '')
-    .trim();
+    // Remove any internal comments, thinking tags, tool calls, etc.
+    return (
+        content
+            // Remove <AI_THINK> tags
+            .replace(/<AI_THINK>[\s\S]*?<\/AI_THINK>/gi, "")
+            // Remove <think> tags
+            .replace(/<think>[\s\S]*?<\/think>/gi, "")
+            // Remove <tool_call> tags
+            .replace(/<tool_call>[\s\S]*?<\/tool_call>/gi, "")
+            // Remove HTML comments
+            .replace(/<!-- .*? -->/gi, "")
+            // Remove any remaining XML-style tags that might be internal
+            .replace(/<\/?[A-Z_]+>/gi, "")
+            .trim()
+    );
 }
diff --git a/frontend/lib/prompt-parser.ts b/frontend/lib/prompt-parser.ts
new file mode 100644
index 0000000..4f6fc8e
--- /dev/null
+++ b/frontend/lib/prompt-parser.ts
@@ -0,0 +1,191 @@
+// Enhanced prompt parsing for business rules extraction
+// This module ensures user-defined business rules take precedence over AI-generated values
+
+export interface UserBusinessRules {
+  discount?: number;
+  budget?: number;
+  currency?: string;
+  gstApplicable?: boolean;
+  clientName?: string;
+  projectTitle?: string;
+}
+
+/**
+ * Extracts business rules from user prompt with high precision
+ * These values will override any conflicting AI-generated values
+ */
+export function extractBusinessRulesFromPrompt(prompt: string): UserBusinessRules {
+  const rules: UserBusinessRules = {};
+
+  if (!prompt || typeof prompt !== 'string') {
+    return rules;
+  }
+
+  const cleanPrompt = prompt.toLowerCase().trim();
+
+  // Extract discount patterns with multiple variations
+  const discountPatterns = [
+    /(\d+(?:\.\d+)?)%\s*discount/i,
+    /discount\s*(?:of\s*)?(\d+(?:\.\d+)?)%?/i,
+    /apply\s*(?:a\s*)?(\d+(?:\.\d+)?)%?\s*discount/i,
+    /(\d+(?:\.\d+)?)%\s*off/i,
+    /give\s*(?:them\s*)?(?:a\s*)?(\d+(?:\.\d+)?)%?\s*discount/i,
+    /discount\s*(?:them\s*)?(\d+(?:\.\d+)?)%?/i
+  ];
+
+  for (const pattern of discountPatterns) {
+    const match = prompt.match(pattern);
+    if (match && match[1]) {
+      const discountValue = parseFloat(match[1]);
+      if (discountValue >= 0 && discountValue <= 100) {
+        rules.discount = discountValue;
+        console.log(`ðŸ” [Prompt Parser] Extracted discount: ${discountValue}%`);
+        break;
+      }
+    }
+  }
+
+  // Extract budget patterns with currency handling
+  const budgetPatterns = [
+    /budget\s*(?:is\s*|of\s*)?[\$]?([0-9,]+(?:\.[0-9]{2})?)/i,
+    /[\$]([0-9,]+(?:\.[0-9]{2})?)\s*budget/i,
+    /total\s*(?:of\s*|is\s*)?[\$]?([0-9,]+(?:\.[0-9]{2})?)/i,
+    /maximum\s*(?:of\s*)?[\$]?([0-9,]+(?:\.[0-9]{2})?)/i,
+    /up\s*to\s*[\$]?([0-9,]+(?:\.[0-9]{2})?)/i,
+    /not\s*more\s*than\s*[\$]?([0-9,]+(?:\.[0-9]{2})?)/i,
+    /within\s*[\$]?([0-9,]+(?:\.[0-9]{2})?)/i
+  ];
+
+  for (const pattern of budgetPatterns) {
+    const match = prompt.match(pattern);
+    if (match && match[1]) {
+      const budgetValue = parseFloat(match[1].replace(/,/g, ''));
+      if (budgetValue > 0 && budgetValue < 10000000) { // Reasonable budget range
+        rules.budget = budgetValue;
+        console.log(`ðŸ” [Prompt Parser] Extracted budget: $${budgetValue}`);
+        break;
+      }
+    }
+  }
+
+  // Extract client/company name patterns
+  const clientPatterns = [
+    /\bfor\s+([A-Z][A-Za-z0-9&\s]+(?:Corp|Corporation|Inc|LLC|Ltd|Company|Co|Group|Agency|Services|Solutions|Technologies)?)/i,
+    /\bclient:\s*([A-Z][A-Za-z0-9&\s]+)/i,
+    /\b([A-Z][A-Za-z0-9&\s]+(?:Corp|Corporation|Inc|LLC|Ltd|Company|Co|Group))\s+(?:needs|wants|requires)/i,
+    /\b([A-Z][A-Za-z0-9&\s]{2,30})\s+(?:integration|website|project|campaign|sow)/i,
+  ];
+
+  for (const pattern of clientPatterns) {
+    const match = prompt.match(pattern);
+    if (match && match[1]) {
+      let name = match[1].trim();
+      // Clean up the match
+      name = name.replace(/\s+(integration|website|project|campaign|sow|needs|wants|requires)$/i, '');
+      if (name.length > 2 && name.length < 50) {
+        rules.clientName = name;
+        console.log(`ðŸ” [Prompt Parser] Extracted client name: ${name}`);
+        break;
+      }
+    }
+  }
+
+  // Extract project title patterns
+  const titlePatterns = [
+    /(?:project|sow)\s*(?:title|name):\s*([^.\n]+)/i,
+    /(?:title|name):\s*([^.\n]+)/i,
+    /create\s*(?:a\s*)?sow\s*for\s*([^.\n]+)/i
+  ];
+
+  for (const pattern of titlePatterns) {
+    const match = prompt.match(pattern);
+    if (match && match[1]) {
+      const title = match[1].trim();
+      if (title.length > 3 && title.length < 100) {
+        rules.projectTitle = title;
+        console.log(`ðŸ” [Prompt Parser] Extracted project title: ${title}`);
+        break;
+      }
+    }
+  }
+
+  // Detect currency (default to AUD for Social Garden)
+  if (prompt.includes('USD') || prompt.includes('$USD')) {
+    rules.currency = 'USD';
+  } else if (prompt.includes('EUR') || prompt.includes('â‚¬')) {
+    rules.currency = 'EUR';
+  } else {
+    rules.currency = 'AUD'; // Default for Social Garden
+  }
+
+  // Detect GST applicability (default true for Australian clients)
+  if (cleanPrompt.includes('no gst') || cleanPrompt.includes('without gst') || cleanPrompt.includes('gst exempt')) {
+    rules.gstApplicable = false;
+  } else if (cleanPrompt.includes('international') || cleanPrompt.includes('overseas') || rules.currency !== 'AUD') {
+    rules.gstApplicable = false;
+  } else {
+    rules.gstApplicable = true; // Default for Australian clients
+  }
+
+  return rules;
+}
+
+/**
+ * Validates extracted business rules for consistency
+ */
+export function validateBusinessRules(rules: UserBusinessRules): { valid: boolean; errors: string[] } {
+  const errors: string[] = [];
+
+  if (rules.discount !== undefined) {
+    if (rules.discount < 0 || rules.discount > 100) {
+      errors.push(`Invalid discount: ${rules.discount}%. Must be between 0% and 100%.`);
+    }
+  }
+
+  if (rules.budget !== undefined) {
+    if (rules.budget <= 0) {
+      errors.push(`Invalid budget: $${rules.budget}. Must be greater than 0.`);
+    }
+    if (rules.budget > 10000000) {
+      errors.push(`Invalid budget: $${rules.budget}. Exceeds reasonable maximum.`);
+    }
+  }
+
+  return {
+    valid: errors.length === 0,
+    errors
+  };
+}
+
+/**
+ * Formats business rules for logging and debugging
+ */
+export function formatBusinessRules(rules: UserBusinessRules): string {
+  const parts: string[] = [];
+
+  if (rules.discount !== undefined) {
+    parts.push(`Discount: ${rules.discount}%`);
+  }
+
+  if (rules.budget !== undefined) {
+    parts.push(`Budget: $${rules.budget.toLocaleString()}`);
+  }
+
+  if (rules.clientName) {
+    parts.push(`Client: ${rules.clientName}`);
+  }
+
+  if (rules.projectTitle) {
+    parts.push(`Title: ${rules.projectTitle}`);
+  }
+
+  if (rules.currency) {
+    parts.push(`Currency: ${rules.currency}`);
+  }
+
+  if (rules.gstApplicable !== undefined) {
+    parts.push(`GST: ${rules.gstApplicable ? 'Applicable' : 'Exempt'}`);
+  }
+
+  return parts.length > 0 ? parts.join(', ') : 'No business rules extracted';
+}
