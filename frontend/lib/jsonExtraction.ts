/**
 * JSON Extraction Utilities
 *
 * Provides reliable extraction of JSON code blocks from markdown responses
 * generated by the AI. Handles multiple code blocks, malformed JSON, and
 * various edge cases gracefully.
 */

export interface JsonExtractionResult {
  json: Record<string, any> | null;
  error: string | null;
  rawJson: string | null;
}

/**
 * Extract JSON code block from markdown response
 *
 * Looks for ```json ... ``` blocks and attempts to parse the content.
 * Returns structured result with parsed JSON, error message, or raw JSON string.
 *
 * @param markdown - The markdown string potentially containing JSON code blocks
 * @returns JsonExtractionResult with json, error, and rawJson
 *
 * @example
 * const result = extractJsonFromMarkdown(aiResponse);
 * if (result.json) {
 *   console.log("Parsed successfully:", result.json);
 * } else {
 *   console.warn("Extraction failed:", result.error);
 * }
 */
export function extractJsonFromMarkdown(
  markdown: string,
): JsonExtractionResult {
  if (!markdown || typeof markdown !== 'string') {
    return {
      json: null,
      error: 'Input must be a non-empty string',
      rawJson: null,
    };
  }

  // Look for ```json ... ``` blocks
  // Handles various whitespace and newline scenarios
  const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/i;
  const match = markdown.match(jsonBlockRegex);

  if (!match || !match[1]) {
    return {
      json: null,
      error: 'No JSON code block (```json ... ```) found in markdown',
      rawJson: null,
    };
  }

  const rawJson = match[1].trim();

  try {
    const parsed = JSON.parse(rawJson);
    return {
      json: parsed,
      error: null,
      rawJson,
    };
  } catch (e) {
    const errorMsg =
      e instanceof SyntaxError
        ? `JSON parse error at line ${e.message}`
        : `JSON parse error: ${String(e)}`;

    return {
      json: null,
      error: errorMsg,
      rawJson,
    };
  }
}

/**
 * Extract all JSON code blocks from markdown (for multi-block responses)
 *
 * Returns an array of extraction results, one per code block found.
 * Useful for responses with multiple JSON structures.
 *
 * @param markdown - The markdown string potentially containing multiple JSON code blocks
 * @returns Array of JsonExtractionResult objects
 */
export function extractAllJsonFromMarkdown(
  markdown: string,
): JsonExtractionResult[] {
  if (!markdown || typeof markdown !== 'string') {
    return [];
  }

  const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/gi;
  const matches = Array.from(markdown.matchAll(jsonBlockRegex));

  return matches.map((match) => {
    const rawJson = match[1].trim();

    try {
      const parsed = JSON.parse(rawJson);
      return {
        json: parsed,
        error: null,
        rawJson,
      };
    } catch (e) {
      const errorMsg =
        e instanceof SyntaxError
          ? `JSON parse error at line ${e.message}`
          : `JSON parse error: ${String(e)}`;

      return {
        json: null,
        error: errorMsg,
        rawJson,
      };
    }
  });
}

/**
 * Safely get nested property from JSON object with type checking
 *
 * Prevents "cannot read property of undefined" errors.
 *
 * @param obj - The object to access
 * @param path - Dot-separated path to property (e.g., "scopeItems[0].role")
 * @param defaultValue - Value to return if path doesn't exist
 * @returns The value at the path, or defaultValue if not found
 *
 * @example
 * const role = safeGet(aiJson, "scopeItems[0].role", "Unknown");
 */
export function safeGet(
  obj: any,
  path: string,
  defaultValue: any = null,
): any {
  try {
    // Convert array bracket notation to dot notation
    // e.g., "items[0].name" -> "items.0.name"
    const normalizedPath = path
      .replace(/\[(\d+)\]/g, '.$1')
      .replace(/^\[/, '')
      .split('.');

    let current = obj;
    for (const key of normalizedPath) {
      if (current === null || current === undefined) {
        return defaultValue;
      }
      current = current[key];
    }

    return current !== undefined ? current : defaultValue;
  } catch (e) {
    return defaultValue;
  }
}

/**
 * Validate that JSON has the expected structure for pricing data
 *
 * Checks for required fields for both v3.1 (single-scope) and v4.1 (multi-scope) formats.
 *
 * @param json - The parsed JSON object
 * @returns Object with { isValid: boolean, format: string, errors: string[] }
 *
 * @example
 * const validation = validatePricingJson(parsed);
 * if (!validation.isValid) {
 *   console.warn("Invalid format:", validation.errors);
 * }
 */
export function validatePricingJson(
  json: Record<string, any>,
): {
  isValid: boolean;
  format: 'v3.1' | 'v4.1' | 'unknown';
  errors: string[];
} {
  const errors: string[] = [];
  let format: 'v3.1' | 'v4.1' | 'unknown' = 'unknown';

  // Check for v4.1 multi-scope format
  if (Array.isArray(json.scopeItems)) {
    format = 'v4.1';
    if (json.scopeItems.length === 0) {
      errors.push('scopeItems array is empty');
    }
    for (let i = 0; i < json.scopeItems.length; i++) {
      const scope = json.scopeItems[i];
      if (!Array.isArray(scope.roles)) {
        errors.push(`scopeItems[${i}].roles must be an array`);
      }
    }
  }
  // Check for v3.1 single-scope format
  else if (
    Array.isArray(json.roles) ||
    Array.isArray(json.suggestedRoles)
  ) {
    format = 'v3.1';
    const rolesArray = json.roles || json.suggestedRoles;
    if (rolesArray.length === 0) {
      errors.push('roles array is empty');
    }
  } else {
    errors.push(
      'JSON must contain either scopeItems (v4.1) or roles/suggestedRoles (v3.1)',
    );
  }

  // Validate individual role objects
  if (format !== 'unknown') {
    const allRoles: any[] = [];
    if (format === 'v4.1') {
      for (const scope of json.scopeItems) {
        allRoles.push(...(scope.roles || []));
      }
    } else {
      allRoles.push(
        ...(json.roles || json.suggestedRoles || []),
      );
    }

    for (let i = 0; i < allRoles.length; i++) {
      const role = allRoles[i];
      if (!role.role || typeof role.role !== 'string') {
        errors.push(
          `roles[${i}].role must be a non-empty string`,
        );
      }
      if (
        typeof role.hours !== 'number' ||
        role.hours < 0
      ) {
        errors.push(
          `roles[${i}].hours must be a non-negative number`,
        );
      }
    }
  }

  return {
    isValid: errors.length === 0,
    format,
    errors,
  };
}

/**
 * Extract pricing JSON and validate it
 *
 * Combines extraction and validation into a single operation.
 *
 * @param markdown - The markdown string from AI response
 * @returns Object with { json, format, isValid, extractionError, validationErrors }
 */
export function extractAndValidatePricingJson(
  markdown: string,
): {
  json: Record<string, any> | null;
  format: 'v3.1' | 'v4.1' | 'unknown';
  isValid: boolean;
  extractionError: string | null;
  validationErrors: string[];
} {
  const extraction = extractJsonFromMarkdown(markdown);

  if (!extraction.json) {
    return {
      json: null,
      format: 'unknown',
      isValid: false,
      extractionError: extraction.error,
      validationErrors: [],
    };
  }

  const validation = validatePricingJson(extraction.json);

  return {
    json: extraction.json,
    format: validation.format,
    isValid: validation.isValid,
    extractionError: null,
    validationErrors: validation.errors,
  };
}
